<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 
 <title>世间自古有情痴</title>
 <link href="https://zhuiyi1997.github.io//atom.xml" rel="self"/>
 <link href="https://zhuiyi1997.github.io/"/>
 <updated>2017-01-14T21:10:07+08:00</updated>
 <id>https://zhuiyi1997.github.io//</id>
 <author>
   <name>追憶</name>
 </author>

 
 <entry>
   <title>windows下搭建symfony环境</title>
   <link href="https://zhuiyi1997.github.io//2017/01/14/windows%E5%AE%89%E8%A3%85symfony.html"/>
   <updated>2017-01-14T00:00:00+08:00</updated>
   <id>urn:uuid:b87da13a-a4dd-402f-b06a-cef7eeee2d80</id>
   <content type="html">&lt;p&gt;1.下载安装php,并将php添加到环境变量中&lt;/p&gt;

&lt;p&gt;2.进入到项目根目录&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;php -r &quot;readfile(&#39;http://symfony.com/installer&#39;);&quot; &amp;gt; symfony.phar
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3.等待下载symfony.phar文件&lt;/p&gt;

&lt;p&gt;4.下载完成之后，在目录下面执行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;php symfony.phar
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;5.创建新工程&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;php symfony.phar new projectName
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;6.如果php版本是5.6及以上可能会遇到cUrl error 60的错误&lt;/p&gt;

&lt;p&gt;7.访问https://curl.haxx.se/ca/cacert.pem 将页面的内容拷贝复制到本地路径“路径/cacert.pem”&lt;/p&gt;

&lt;p&gt;8.修改php.ini 配置文件&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl.cainfo = &quot;路径\cacert.pem&quot;
&lt;/code&gt;&lt;/pre&gt;
</content>
 </entry>
 
 <entry>
   <title>ubuntu安装lnmp环境</title>
   <link href="https://zhuiyi1997.github.io//2016/12/20/ubuntu%E5%AE%89%E8%A3%85lnmp.html"/>
   <updated>2016-12-20T00:00:00+08:00</updated>
   <id>urn:uuid:b87da13a-a4dd-402f-b06a-cef7eeee2d80</id>
   <content type="html">&lt;p&gt;首先ctrl+alt+t打开终端&lt;/p&gt;

&lt;p&gt;1.更新软件源:
    sudo apt-get update
2.安装nginx
    sudo apt-get install nginx
3.启动nginx
    sudo /etc/init.d/nginx start
4.安装php5和mysql
    sudo apt-get install php5-cli php5-cgi mysql-server php5-mysql&lt;/p&gt;

&lt;p&gt;5.修改mysql用户权限
 1)从终端进入mysql
     mysql -u root -p123456
 2)更改用户权限: grant 权限 on 数据库对象 to 用户
   grant all on &lt;em&gt;.&lt;/em&gt; to root@’%’ identified by ‘123456’;
 3)刷新让权限生效
   flush privileges;&lt;/p&gt;

&lt;p&gt;6.修改mysql下配置文件
 1)修改mysql的配置文件
   sudo vi/etc/mysql/my.cnf
 2)将bind-address = 127.0.0.1前面加上#注释掉，这样就可以远程连接数据库了。&lt;/p&gt;

&lt;p&gt;7.安装php5-fpm
  sudo apt-get install php5-fpm&lt;/p&gt;

&lt;p&gt;8.配置nginx并重启服务
 1)然后同样进入vi编辑
    sudo vi /etc/nginx/sites-enabled/default
 2)将里面的内容修改成以下样子
  (把里面server的listen 80和location ~.php${的注释打开，其他的看着改)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;server{
   listen 80;
   root /usr/share/nginx/www;
   index index.php index.html index.htm;
   server_name localhost;
   location / {
       try_files $uri $uri/ /index.html;
   }
   location ~ \.php$ {
       fastcgi_pass 127.0.0.1:9000;
       fastcgi_index index.php;
       fastcgi_param SCRIPT_FILENAME /usr/share/nginx/www$fastcgi_script_name;
       include /etc/nginx/fastcgi_params;
   }    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3).改完保存退出&lt;/p&gt;

&lt;p&gt;9.启动fastcgi php
  sudo service php5-fpm start&lt;/p&gt;

&lt;p&gt;10.重启nginx服务
  sudo service nginx restart&lt;/p&gt;

&lt;p&gt;11.安装php相关扩展(xdebug,memcache,oauth等)
 1）安装curl
   sudo apt-get install php5-curl
 2)安装gettext:
   sudo apt-get install php-gettext
 3)安装gd库：
   sudo apt-get install php5-gd
 4)安装mcrypt:
   sudo apt-get install php5-mcrypt
 5)安装memcache
   a)安装服务器：
     sudo apt-get install memcached
     memcached -d -m 50 -p 11211 -u root
     -m指定使用多少兆的缓存空间（这里50） -p指定要监听的端口 (11211) -u指定哪个用户使用(root)
   b)安装php模块
     sudo apt-get install php5-memcache
 6)安装oauth:基于pecl的
   a)sudo apt-get install php5-dev php-pear libpcre3-dev
     sudo pecl install oauth(要确保linux系统里可以make)
   b)修改配置文件
     sudo vi /etc/php5/fpm/php.ini
     在最后添加&lt;/p&gt;

&lt;p&gt;extension=oauth.so&lt;/p&gt;

&lt;p&gt;12)安装ssh2:
   sudo apt-get install libssh2-php
 13)安装xdebug
   1)sudo apt-get install php5-xdebug
   2)修改php配置文件
    sudo vi /etc/php5/fpm/php.ini
    将display_errors和html_errors都改为On
 14)重启php服务:
   sudo service php5-fpm restart&lt;/p&gt;

&lt;p&gt;这时环境搭配就成功了.服务器的文件路径是/usr/share/nginx/www。&lt;/p&gt;

&lt;p&gt;打开发现里面有个index.html文件。然后在浏览器输入localhost/index.html  就可以看到亲切的
Welcome to nginx!&lt;/p&gt;

&lt;p&gt;使用终端常用命令:&lt;/p&gt;

&lt;p&gt;查看文件权限
ls -l /dir/files
以管理员身份执行命令:
sudo …..
更改文件权限
sodu chmod 777 xxxx(777)是开放所有权限  644是管理员有读写，其他人只有读权限&lt;/p&gt;

&lt;p&gt;vi编写常用命令:
从光标所在的地方插入
i
从光标之后插入
a
退出编辑模式
esc
删除光标在内的当前行及其下面的n-1行内容（退出编辑模式才可使用）
ndd
删除字符（退出编辑模式才可使用）
X(大写，删除光标前)    x(小写，删除光标后的)
保存并退出vi(退出编辑模式才可使用)
:x
不保存并退出vi(退出编辑模式才可使用)
:q!&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>openssl进行非对称加密和对称加密的php示例</title>
   <link href="https://zhuiyi1997.github.io//2016/12/05/jiami.html"/>
   <updated>2016-12-05T00:00:00+08:00</updated>
   <id>urn:uuid:b87da13a-a4dd-402f-b06a-cef7eeee2d80</id>
   <content type="html">&lt;p&gt;确保开启PHP的openssl扩展：extension=php_openssl.dll&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?php
/**
 * @file
 * 作者：yunke url：http://blog.csdn.net/u011474028
 *
 */
header(&quot;Content-Type:text/html; charset=utf-8&quot;);

$key_file = &quot;yunkeserver.key&quot;; //私钥
$publickey_file = &quot;yunkeserver.crt&quot;; //证书文件
//$publickey_file=&quot;server.crt&quot;;//和私钥不匹配的证书文件
$data_file = &quot;msg.txt&quot;; //待加密数据文件

$private_key = openssl_get_privatekey(file_get_contents($key_file)); //获取私钥 非字符串类型  为资源类型
echo &quot;私钥为：&amp;lt;br&amp;gt;&quot; . $private_key . &quot;&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;&quot;;
$public_key = openssl_get_publickey(file_get_contents($publickey_file)); //获取公钥 非字符串类型  为资源类型
echo &quot;公钥为：&amp;lt;br&amp;gt;&quot; . $public_key . &quot;&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;&quot;;

/*
$str_key = &#39;&#39;; //KEY的字符串表示
if (openssl_pkey_export($private_key, $str_key)) { //需要正确配置openssl.cnf文件才可以成功
    echo &quot;密钥的字符串表示为：&amp;lt;br&amp;gt;&quot; . $str_key . &quot;&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;&quot;;
} else {
    echo &quot;密钥的字符串化失败：&amp;lt;br&amp;gt;&quot;;
    while ($msg = openssl_error_string()) {
        echo $msg . &quot;&amp;lt;br /&amp;gt;\n&quot;;
    }
    echo &quot;&amp;lt;br /&amp;gt;&quot;;
}
*/
 //print_r(openssl_pkey_get_details ( $public_key )); //输出密钥的详细信息 这里可以看出私钥里面是包含公钥的

$data = file_get_contents($data_file);
echo &quot;明码数据为：&amp;lt;br&amp;gt;&quot; . $data . &quot;&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;&quot;;

$crypted_data = null; //密文
if (openssl_private_encrypt($data, $crypted_data, $private_key)) {
    echo &quot;以下是私钥加密的密文：&amp;lt;br&amp;gt;&quot; . $crypted_data . &quot;&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;&quot;;
} else {
    echo &quot;加密失败：&amp;lt;br&amp;gt;&quot;;
    while ($msg = openssl_error_string()) {
        echo $msg . &quot;&amp;lt;br /&amp;gt;\n&quot;;
    }
}
$decrypted_data = null; //加密还原后的明文
if (openssl_public_decrypt($crypted_data, $decrypted_data, $public_key)) {
    echo &quot;以下是经过公钥解密后的明文：&amp;lt;br&amp;gt;&quot; . $decrypted_data . &quot;&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;&quot;;
} else {
    echo &quot;解密失败：&amp;lt;br&amp;gt;&quot;;
    while ($msg = openssl_error_string()) {
        echo $msg . &quot;&amp;lt;br /&amp;gt;\n&quot;;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;//以上为非对称加密   以下演示对称加密&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$key=&quot;123456&quot;; //设置一个共享密码
$cipher=&#39;&#39;;//加密算法
$arr=openssl_get_cipher_methods(); //获取支持的加密算法 数组的key和值并没有对应关系
$cipher=$arr[20];
echo &quot;选择的加密算法是：$cipher &amp;lt;br&amp;gt;\n&quot;;
$value=openssl_encrypt($data , $cipher,$key); //第四参数OPENSSL_RAW_DATA输出原始数据 
echo &quot;加密后的密文是：&amp;lt;br&amp;gt;&quot;.$value.&quot;&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;&quot;;
$old_data=openssl_decrypt ( $value,$cipher, $key);
echo &quot;解密还原的明文：&amp;lt;br&amp;gt;&quot;.$old_data.&quot;&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;&quot;;

//print_r($arr);
&lt;/code&gt;&lt;/pre&gt;
</content>
 </entry>
 
 <entry>
   <title>禁用cookie后session是如何设置的</title>
   <link href="https://zhuiyi1997.github.io//2016/10/17/session.html"/>
   <updated>2016-10-17T00:00:00+08:00</updated>
   <id>urn:uuid:b87da13a-a4dd-402f-b06a-cef7eeee2d80</id>
   <content type="html">&lt;p&gt;我们都知道当在session 会话有基于cookie和基于url两种传递SESSIONID的方法。为了实现客户端禁止cookie发送的情况也不影响客户登陆网站，可以设置 php.ini中 session.use_trans_sid=1 ，表示当客户端浏览器禁止cookie的时候，页面上的链接会基于url传递SESSIONID。但是很多人仅仅设置了这一个选项并没有达到效果，本人也 遇到此问题，后来一番研究发现
php.ini 文件中还有两个选项&lt;/p&gt;

&lt;p&gt;session.use_cookies=1&lt;/p&gt;

&lt;p&gt;session.use_only_cookies=1&lt;/p&gt;

&lt;p&gt;仔细琢磨上面的英文就会发现其意义&lt;/p&gt;

&lt;p&gt;session.use_cookies表示是否开始基于cookies的session会话&lt;/p&gt;

&lt;p&gt;session.use_only_cookies 表示是否只开启基于cookies的session的会话方式&lt;/p&gt;

&lt;p&gt;所以如果想要在浏览器开启cookie的时候用基于cookie的方式，在未开启cookie的时候使用url的方式就进行如下设置（最常用的方式，推荐）
在php.ini文件中&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;session.use_trans_sid=1
session.use_only_cookies=0
session.use_cookies=1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或者 在php程序中&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ini_set(“session.use_trans_sid”,”1″);
ini_set(“session.use_only_cookies”,0);
ini_set(“session.use_cookies”,1);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果不管浏览器是否开启cookie，都使用url的方式就进行如下设置（这个例子主要想说明一下设置session.use_only_cookies 和 session.use_cookies的区别）
在php.ini文件中&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;session.use_trans_sid=1
session.use_only_cookies=0
session.use_cookies=0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或者 在php程序中&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ini_set(“session.use_trans_sid”,”1″);
ini_set(“session.use_only_cookies”,0);
ini_set(“session.use_cookies”,0);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;动手自己试一试 你就会明白session.use_only_cookies 和 session.use_cookies的区别。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>PSR1代码规范4</title>
   <link href="https://zhuiyi1997.github.io//2016/10/16/psr4.html"/>
   <updated>2016-10-16T00:00:00+08:00</updated>
   <id>urn:uuid:b87da13a-a4dd-402f-b06a-cef7eeee2d80</id>
   <content type="html">&lt;h2 id=&quot;section&quot;&gt;1. 概况&lt;/h2&gt;

&lt;p&gt;这个 PSR 描述的是通过文件路径&lt;a href=&quot;http://php.net/autoload&quot;&gt;自动载入&lt;/a&gt;类的指南；它作为对 &lt;a href=&quot;https://github.com/hfcorriez/fig-standards/tree/master/accepted/zh_CN/PSR-0.md&quot;&gt;PSR-0&lt;/a&gt; 的补充；根据这个
指导如何规范存放文件来自动载入；&lt;/p&gt;

&lt;h2 id=&quot;specification&quot;&gt;2. 说明（Specification）&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;术语「类」是一个泛称；它包含类，接口，traits 以及其他类似的结构；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;完全限定类名应该类似如下范例：&lt;/p&gt;

    &lt;p&gt;&amp;lt;NamespaceName&amp;gt;(&amp;lt;SubNamespaceNames&amp;gt;)*&amp;lt;ClassName&amp;gt;&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;完全限定类名必须有一个顶级命名空间（Vendor Name）；&lt;/li&gt;
      &lt;li&gt;完全限定类名可以有多个子命名空间；&lt;/li&gt;
      &lt;li&gt;完全限定类名应该有一个终止类名；&lt;/li&gt;
      &lt;li&gt;下划线在完全限定类名中是没有特殊含义的；&lt;/li&gt;
      &lt;li&gt;字母在完全限定类名中可以是任何大小写的组合；&lt;/li&gt;
      &lt;li&gt;所有类名必须以大小写敏感的方式引用；&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;当从完全限定类名载入文件时：&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;在完全限定类名中，连续的一个或几个子命名空间构成的命名空间前缀（不包括顶级命名空间的分隔符），至少对应着至少一个基础目录。&lt;/li&gt;
      &lt;li&gt;在「命名空间前缀」后的连续子命名空间名称对应一个「基础目录」下的子目录，其中的命名
空间分隔符表示目录分隔符。子目录名称必须和子命名空间名大小写匹配；&lt;/li&gt;
      &lt;li&gt;终止类名对应一个以 &lt;code&gt;.php&lt;/code&gt; 结尾的文件。文件名必须和终止类名大小写匹配；&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;自动载入器的实现不可抛出任何异常，不可引发任何等级的错误；也不应返回值；&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;section-1&quot;&gt;3. 范例&lt;/h2&gt;

&lt;p&gt;如下表格展示的是与完全限定类名、命名空间前缀和基础目录相对应的文件路径：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;完全限定类名&lt;/th&gt;
      &lt;th&gt;命名空间前缀&lt;/th&gt;
      &lt;th&gt;基础目录&lt;/th&gt;
      &lt;th&gt;实际的文件路径&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;\Acme\Log\Writer\File_Writer&lt;/td&gt;
      &lt;td&gt;Acme\Log\Writer&lt;/td&gt;
      &lt;td&gt;./acme-log-writer/lib/&lt;/td&gt;
      &lt;td&gt;./acme-log-writer/lib/File_Writer.php&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;\Aura\Web\Response\Status&lt;/td&gt;
      &lt;td&gt;Aura\Web&lt;/td&gt;
      &lt;td&gt;/path/to/aura-web/src/&lt;/td&gt;
      &lt;td&gt;/path/to/aura-web/src/Response/Status.php&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;\Symfony\Core\Request&lt;/td&gt;
      &lt;td&gt;Symfony\Core&lt;/td&gt;
      &lt;td&gt;./vendor/Symfony/Core/&lt;/td&gt;
      &lt;td&gt;./vendor/Symfony/Core/Request.php&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;\Zend\Acl&lt;/td&gt;
      &lt;td&gt;Zend&lt;/td&gt;
      &lt;td&gt;/usr/includes/Zend/&lt;/td&gt;
      &lt;td&gt;/usr/includes/Zend/Acl.php&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;例子中的自动载入器非常适应这个指南，请参照 &lt;a href=&quot;http://www.php-fig.org/psr/psr-4/PSR-4-autoloader-examples.md&quot;&gt;示例文件&lt;/a&gt;。由于可能随时变更，实例不能作为指南的一部分。&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>PSR1代码规范3</title>
   <link href="https://zhuiyi1997.github.io//2016/10/16/psr3.html"/>
   <updated>2016-10-16T00:00:00+08:00</updated>
   <id>urn:uuid:b87da13a-a4dd-402f-b06a-cef7eeee2d80</id>
   <content type="html">&lt;h1 id=&quot;section&quot;&gt;日志接口&lt;/h1&gt;

&lt;p&gt;本文档描述了日志类库的通用接口。&lt;/p&gt;

&lt;p&gt;主要目标是让类库获得一个&lt;code&gt;Psr\Log\LoggerInterface&lt;/code&gt;对象并能通过简单通用的方式来写日志。有自定义需求的框架和CMS&lt;code&gt;可以&lt;/code&gt;根据情况扩展这个接口，但&lt;code&gt;推荐&lt;/code&gt;保持和该文档的兼容性，以确保应用中使用到的第三方库能将日志集中写到应用日志里。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://tools.ietf.org/html/rfc2119&quot;&gt;RFC 2119&lt;/a&gt;中的&lt;code&gt;必须(MUST)&lt;/code&gt;，&lt;code&gt;不可(MUST NOT)&lt;/code&gt;，&lt;code&gt;建议(SHOULD)&lt;/code&gt;，&lt;code&gt;不建议(SHOULD NOT)&lt;/code&gt;，&lt;code&gt;可以/可能(MAY)&lt;/code&gt;等关键词将在本节用来做一些解释性的描述。&lt;/p&gt;

&lt;p&gt;关键词&lt;code&gt;实现者&lt;/code&gt;在这个文档被解释为：在日志相关的库或框架实现&lt;code&gt;LoggerInterface&lt;/code&gt;接口的开发人员。用这些实现者开发出来的类库的人都被称作&lt;code&gt;用户&lt;/code&gt;。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;section-1&quot;&gt;规范&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;section-2&quot;&gt;1.1 基础&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code&gt;LoggerInterface&lt;/code&gt;暴露八个接口用来记录八个等级(debug, info, notice, warning, error, critical, alert, emergency)的日志。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;第九个方法是&lt;code&gt;log&lt;/code&gt;，接受日志等级作为第一个参数。用一个日志等级常量来调用这个方法&lt;code&gt;必须&lt;/code&gt;和直接调用指定等级方法的结果一致。用一个本规范中未定义且不为具体实现所知的日志等级来调用该方法&lt;code&gt;必须&lt;/code&gt;抛出一个&lt;code&gt;Psr\Log\InvalidArgumentException&lt;/code&gt;。&lt;code&gt;不推荐&lt;/code&gt;使用自定义的日志等级，除非你非常确定当前类库对其有所支持。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-3&quot;&gt;1.2 消息&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;每个方法都接受一个字符串，或者一个有&lt;code&gt;__toString&lt;/code&gt;方法的对象作为&lt;code&gt;message&lt;/code&gt;参数。&lt;code&gt;实现者&lt;/code&gt; &lt;code&gt;可以&lt;/code&gt;对传入的对象有特殊的处理。如果没有，&lt;code&gt;实现者&lt;/code&gt; &lt;code&gt;必须&lt;/code&gt;将它转换成字符串。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code&gt;message&lt;/code&gt;参数中&lt;code&gt;可能&lt;/code&gt;包含一些&lt;code&gt;可以&lt;/code&gt;被&lt;code&gt;context&lt;/code&gt;参数的数值所替换的占位符。&lt;/p&gt;

    &lt;p&gt;占位符名字&lt;code&gt;必须&lt;/code&gt;和&lt;code&gt;context&lt;/code&gt;数组类型参数的键名对应。&lt;/p&gt;

    &lt;p&gt;占位符名字&lt;code&gt;必须&lt;/code&gt;使用一对花括号来作为分隔符。在占位符和分隔符之间&lt;code&gt;不能&lt;/code&gt;有任何空格。&lt;/p&gt;

    &lt;p&gt;占位符名字&lt;code&gt;应该&lt;/code&gt;只能由&lt;code&gt;A-Z&lt;/code&gt;，&lt;code&gt;a-z&lt;/code&gt;，&lt;code&gt;0-9&lt;/code&gt;，下划线&lt;code&gt;_&lt;/code&gt;和句号&lt;code&gt;.&lt;/code&gt;组成。其它的字符作为以后占位符规范的保留字。&lt;/p&gt;

    &lt;p&gt;&lt;code&gt;实现者&lt;/code&gt; &lt;code&gt;可以&lt;/code&gt;使用占位符来实现不同的转义和翻译日志成文。因为&lt;code&gt;用户&lt;/code&gt;并不知道上下文数据会是什么，所以&lt;code&gt;不推荐&lt;/code&gt;提前转义占位符。&lt;/p&gt;

    &lt;p&gt;下面提供一个占位符替换的例子，仅作为参考：&lt;/p&gt;

    &lt;p&gt;```php
  &amp;lt;?php
  /**
   * Interpolates context values into the message placeholders.
   */
  function interpolate($message, array $context = array())
  {
      // build a replacement array with braces around the context keys
      $replace = array();
      foreach ($context as $key =&amp;gt; $val) {
          $replace[’{‘ . $key . ‘}’] = $val;
      }&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;  // interpolate replacement values into the message and return
  return strtr($message, $replace);   }
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;// a message with brace-delimited placeholder names
  $message = “User {username} created”;&lt;/p&gt;

    &lt;p&gt;// a context array of placeholder names =&amp;gt; replacement values
  $context = array(‘username’ =&amp;gt; ‘bolivar’);&lt;/p&gt;

    &lt;p&gt;// echoes “Username bolivar created”
  echo interpolate($message, $context);
  ```&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-4&quot;&gt;1.3 上下文&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;每个方法接受一个数组作为&lt;code&gt;context&lt;/code&gt;参数，用来存储不适合在字符串中填充的信息。数组可以包括任何东西。&lt;code&gt;实现者&lt;/code&gt; &lt;code&gt;必须&lt;/code&gt;确保他们尽可能包容的对&lt;code&gt;context&lt;/code&gt;参数进行处理。一个&lt;code&gt;context&lt;/code&gt;参数的给定值&lt;code&gt;不可&lt;/code&gt;导致抛出异常，也&lt;code&gt;不可&lt;/code&gt;产生任何PHP错误，警告或者提醒。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果在&lt;code&gt;context&lt;/code&gt;参数中传入了一个&lt;code&gt;异常&lt;/code&gt;对象，它必须以&lt;code&gt;exception&lt;/code&gt;作为键名。记录异常轨迹是通用的模式，并且可以在日志系统支持的情况下从异常中提取出整个调用栈。&lt;code&gt;实现者&lt;/code&gt;在将&lt;code&gt;exception&lt;/code&gt;当做&lt;code&gt;异常&lt;/code&gt;对象来使用之前&lt;code&gt;必须&lt;/code&gt;去验证它是不是一个&lt;code&gt;异常&lt;/code&gt;对象，因为它&lt;code&gt;可能&lt;/code&gt;包含着任何东西。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-5&quot;&gt;1.4 助手类和接口&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code&gt;Psr\Log\AbstractLogger&lt;/code&gt;类可以让你通过继承它并实现通用的&lt;code&gt;log&lt;/code&gt;方法来方便的实现&lt;code&gt;LoggerInterface&lt;/code&gt;接口。而其他八个方法将会把消息和上下文转发给&lt;code&gt;log&lt;/code&gt;方法。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;类似的，使用&lt;code&gt;Psr\Log\LoggerTrait&lt;/code&gt;只需要你实现通用的&lt;code&gt;log&lt;/code&gt;方法。注意特性是不能用来实现接口的，所以你依然需要在你的类中&lt;code&gt;implement LoggerInterface&lt;/code&gt;。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code&gt;Psr\Log\NullLogger&lt;/code&gt;是和接口一起提供的。它在没有可用的日志记录器时，&lt;code&gt;可以&lt;/code&gt;为使用日志接口的&lt;code&gt;用户&lt;/code&gt;们提供一个后备的“黑洞”。但是，当&lt;code&gt;context&lt;/code&gt;参数的构建非常耗时的时候，直接判断是否需要记录日志可能是个更好的选择。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code&gt;Psr\Log\LoggerAwareInterface&lt;/code&gt;只有一个&lt;code&gt;setLogger(LoggerInterface $logger)&lt;/code&gt;方法，它可以在框架中用来随意设置一个日志记录器。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code&gt;Psr\Log\LoggerAwareTrait&lt;/code&gt;特性可以被用来在各个类中轻松实现相同的接口。通过它可以访问到&lt;code&gt;$this-&amp;gt;logger&lt;/code&gt;。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code&gt;Psr\Log\LogLevel&lt;/code&gt;类拥有八个日志等级的常量。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;section-6&quot;&gt;包&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;a href=&quot;https://packagist.org/packages/psr/log&quot;&gt;psr/log&lt;/a&gt;中提供了上文描述过的接口和类，以及相关的异常类，还有一组用来验证你的实现的单元测试。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;psrlogloggerinterface&quot;&gt;&lt;code&gt;Psr\Log\LoggerInterface&lt;/code&gt;&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;```php
&amp;lt;?php&lt;/p&gt;

&lt;p&gt;namespace Psr\Log;&lt;/p&gt;

&lt;p&gt;/**
 * Describes a logger instance
 *
 * The message MUST be a string or object implementing __toString().
 *
 * The message MAY contain placeholders in the form: {foo} where foo
 * will be replaced by the context data in key “foo”.
 *
 * The context array can contain arbitrary data, the only assumption that
 * can be made by implementors is that if an Exception instance is given
 * to produce a stack trace, it MUST be in a key named “exception”.
 *
 * See https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-3-logger-interface.md
 * for the full interface specification.
 */
interface LoggerInterface
{
    /**
     * System is unusable.
     *
     * @param string $message
     * @param array $context
     * @return null
     */
    public function emergency($message, array $context = array());&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
 * Action must be taken immediately.
 *
 * Example: Entire website down, database unavailable, etc. This should
 * trigger the SMS alerts and wake you up.
 *
 * @param string $message
 * @param array $context
 * @return null
 */
public function alert($message, array $context = array());

/**
 * Critical conditions.
 *
 * Example: Application component unavailable, unexpected exception.
 *
 * @param string $message
 * @param array $context
 * @return null
 */
public function critical($message, array $context = array());

/**
 * Runtime errors that do not require immediate action but should typically
 * be logged and monitored.
 *
 * @param string $message
 * @param array $context
 * @return null
 */
public function error($message, array $context = array());

/**
 * Exceptional occurrences that are not errors.
 *
 * Example: Use of deprecated APIs, poor use of an API, undesirable things
 * that are not necessarily wrong.
 *
 * @param string $message
 * @param array $context
 * @return null
 */
public function warning($message, array $context = array());

/**
 * Normal but significant events.
 *
 * @param string $message
 * @param array $context
 * @return null
 */
public function notice($message, array $context = array());

/**
 * Interesting events.
 *
 * Example: User logs in, SQL logs.
 *
 * @param string $message
 * @param array $context
 * @return null
 */
public function info($message, array $context = array());

/**
 * Detailed debug information.
 *
 * @param string $message
 * @param array $context
 * @return null
 */
public function debug($message, array $context = array());

/**
 * Logs with an arbitrary level.
 *
 * @param mixed $level
 * @param string $message
 * @param array $context
 * @return null
 */
public function log($level, $message, array $context = array()); } ```
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;psrlogloggerawareinterface&quot;&gt;&lt;code&gt;Psr\Log\LoggerAwareInterface&lt;/code&gt;&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;```php
&amp;lt;?php&lt;/p&gt;

&lt;p&gt;namespace Psr\Log;&lt;/p&gt;

&lt;p&gt;/**
 * Describes a logger-aware instance
 */
interface LoggerAwareInterface
{
    /**
     * Sets a logger instance on the object
     *
     * @param LoggerInterface $logger
     * @return null
     */
    public function setLogger(LoggerInterface $logger);
}
```&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;psrlogloglevel&quot;&gt;&lt;code&gt;Psr\Log\LogLevel&lt;/code&gt;&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;```php
&amp;lt;?php&lt;/p&gt;

&lt;p&gt;namespace Psr\Log;&lt;/p&gt;

&lt;p&gt;/**
 * Describes log levels
 */
class LogLevel
{
    const EMERGENCY = ‘emergency’;
    const ALERT     = ‘alert’;
    const CRITICAL  = ‘critical’;
    const ERROR     = ‘error’;
    const WARNING   = ‘warning’;
    const NOTICE    = ‘notice’;
    const INFO      = ‘info’;
    const DEBUG     = ‘debug’;
}
```&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>PSR1代码规范2</title>
   <link href="https://zhuiyi1997.github.io//2016/10/16/psr2.html"/>
   <updated>2016-10-16T00:00:00+08:00</updated>
   <id>urn:uuid:b87da13a-a4dd-402f-b06a-cef7eeee2d80</id>
   <content type="html">&lt;h1 id=&quot;section&quot;&gt;代码风格指南&lt;/h1&gt;

&lt;p&gt;本手册是基础代码规范(&lt;a href=&quot;https://github.com/hfcorriez/fig-standards/blob/zh_CN/接受/PSR-1-basic-coding-standard.md&quot;&gt;PSR-1&lt;/a&gt;)的继承和扩展。&lt;/p&gt;

&lt;p&gt;为了尽可能的提升阅读其他人代码时的效率，下面例举了一系列的通用规则，特别是有关于PHP代码风格的。&lt;/p&gt;

&lt;p&gt;各个成员项目间的共性组成了这组代码规范。当开发者们在多个项目中合作时，本指南将会成为所有这些项目中共用的一组代码规范。 因此，本指南的益处不在于这些规则本身，而在于在所有项目中共用这些规则。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc2119.txt&quot;&gt;RFC 2119&lt;/a&gt;中的&lt;code&gt;必须(MUST)&lt;/code&gt;，&lt;code&gt;不可(MUST NOT)&lt;/code&gt;，&lt;code&gt;建议(SHOULD)&lt;/code&gt;，&lt;code&gt;不建议(SHOULD NOT)&lt;/code&gt;，&lt;code&gt;可以/可能(MAY)&lt;/code&gt;等关键词将在本节用来做一些解释性的描述。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;section-1&quot;&gt;概述&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;代码&lt;code&gt;必须&lt;/code&gt;遵守 &lt;a href=&quot;https://github.com/hfcorriez/fig-standards/blob/zh_CN/接受/PSR-1-basic-coding-standard.md&quot;&gt;PSR-1&lt;/a&gt;。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;代码&lt;code&gt;必须&lt;/code&gt;使用4个空格来进行缩进，而不是用制表符。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;一行代码的长度&lt;code&gt;不建议&lt;/code&gt;有硬限制；软限制&lt;code&gt;必须&lt;/code&gt;为120个字符，&lt;code&gt;建议&lt;/code&gt;每行代码80个字符或者更少。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在&lt;code&gt;命名空间(namespace)&lt;/code&gt;的声明下面&lt;code&gt;必须&lt;/code&gt;有一行空行，并且在&lt;code&gt;导入(use)&lt;/code&gt;的声明下面也&lt;code&gt;必须&lt;/code&gt;有一行空行。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code&gt;类(class)&lt;/code&gt;的左花括号&lt;code&gt;必须&lt;/code&gt;放到其声明下面自成一行，右花括号则&lt;code&gt;必须&lt;/code&gt;放到类主体下面自成一行。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code&gt;方法(method)&lt;/code&gt;的左花括号&lt;code&gt;必须&lt;/code&gt;放到其声明下面自成一行，右花括号则&lt;code&gt;必须&lt;/code&gt;放到方法主体的下一行。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;所有的&lt;code&gt;属性(property)&lt;/code&gt;和&lt;code&gt;方法(method)&lt;/code&gt; &lt;code&gt;必须&lt;/code&gt;有可见性声明；&lt;code&gt;抽象(abstract)&lt;/code&gt;和&lt;code&gt;终结(final)&lt;/code&gt;声明&lt;code&gt;必须&lt;/code&gt;在可见性声明之前；而&lt;code&gt;静态(static)&lt;/code&gt;声明&lt;code&gt;必须&lt;/code&gt;在可见性声明之后。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在控制结构关键字的后面&lt;code&gt;必须&lt;/code&gt;有一个空格；而&lt;code&gt;方法(method)&lt;/code&gt;和&lt;code&gt;函数(function)&lt;/code&gt;的关键字的后面&lt;code&gt;不可&lt;/code&gt;有空格。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;控制结构的左花括号&lt;code&gt;必须&lt;/code&gt;跟其放在同一行，右花括号&lt;code&gt;必须&lt;/code&gt;放在该控制结构代码主体的下一行。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;控制结构的左括号之后&lt;code&gt;不可&lt;/code&gt;有空格，右括号之前也&lt;code&gt;不可&lt;/code&gt;有空格。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-2&quot;&gt;1.1. 示例&lt;/h3&gt;

&lt;p&gt;这个示例中简单展示了上文中提到的一些规则：&lt;/p&gt;

&lt;p&gt;```php
&amp;lt;?php
namespace Vendor\Package;&lt;/p&gt;

&lt;p&gt;use FooInterface;
use BarClass as Bar;
use OtherVendor\OtherPackage\BazClass;&lt;/p&gt;

&lt;p&gt;class Foo extends Bar implements FooInterface
{
    public function sampleFunction($a, $b = null)
    {
        if ($a === $b) {
            bar();
        } elseif ($a &amp;gt; $b) {
            $foo-&amp;gt;bar($arg1);
        } else {
            BazClass::bar($arg2, $arg3);
        }
    }&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;final public static function bar()
{
    // 方法主体
} } ```
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;section-3&quot;&gt;通则&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;section-4&quot;&gt;2.1 基础代码规范&lt;/h3&gt;

&lt;p&gt;代码&lt;code&gt;必须&lt;/code&gt;遵守 &lt;a href=&quot;https://github.com/hfcorriez/fig-standards/blob/zh_CN/接受/PSR-1-basic-coding-standard.md&quot;&gt;PSR-1&lt;/a&gt; 中的所有规则。&lt;/p&gt;

&lt;h3 id=&quot;section-5&quot;&gt;2.2 源文件&lt;/h3&gt;

&lt;p&gt;所有的PHP源文件&lt;code&gt;必须&lt;/code&gt;使用Unix LF(换行)作为行结束符。&lt;/p&gt;

&lt;p&gt;所有PHP源文件&lt;code&gt;必须&lt;/code&gt;以一个空行结束。&lt;/p&gt;

&lt;p&gt;纯PHP代码源文件的关闭标签&lt;code&gt;?&amp;gt;&lt;/code&gt; &lt;code&gt;必须&lt;/code&gt;省略。&lt;/p&gt;

&lt;h3 id=&quot;section-6&quot;&gt;2.3. 行&lt;/h3&gt;

&lt;p&gt;行长度&lt;code&gt;不可&lt;/code&gt;有硬限制。&lt;/p&gt;

&lt;p&gt;行长度的软限制&lt;code&gt;必须&lt;/code&gt;是120个字符；对于软限制，代码风格检查器&lt;code&gt;必须&lt;/code&gt;警告但&lt;code&gt;不可&lt;/code&gt;报错。&lt;/p&gt;

&lt;p&gt;一行代码的长度&lt;code&gt;不建议&lt;/code&gt;超过80个字符；较长的行&lt;code&gt;建议&lt;/code&gt;拆分成多个不超过80个字符的子行。&lt;/p&gt;

&lt;p&gt;在非空行后面&lt;code&gt;不可&lt;/code&gt;有空格。&lt;/p&gt;

&lt;p&gt;空行&lt;code&gt;可以&lt;/code&gt;用来增强可读性和区分相关代码块。&lt;/p&gt;

&lt;p&gt;一行&lt;code&gt;不可&lt;/code&gt;多于一个语句。&lt;/p&gt;

&lt;h3 id=&quot;section-7&quot;&gt;2.4. 缩进&lt;/h3&gt;

&lt;p&gt;代码&lt;code&gt;必须&lt;/code&gt;使用4个空格，且&lt;code&gt;不可&lt;/code&gt;使用制表符来作为缩进。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;注意：代码中只使用空格，且不和制表符混合使用，将会对避免代码差异，补丁，历史和注解中的一些问题有帮助。空格的使用还可以使通过调整细微的缩进来改进行间对齐变得更加的简单。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;truefalsenull&quot;&gt;2.5. 关键字和 True/False/Null&lt;/h3&gt;

&lt;p&gt;PHP关键字(&lt;a href=&quot;http://php.net/manual/en/reserved.keywords.php&quot;&gt;keywords&lt;/a&gt;)&lt;code&gt;必须&lt;/code&gt;使用小写字母。&lt;/p&gt;

&lt;p&gt;PHP常量&lt;code&gt;true&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt;和&lt;code&gt;null&lt;/code&gt; &lt;code&gt;必须&lt;/code&gt;使用小写字母。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;namespaceuse&quot;&gt;&lt;code&gt;命名空间(Namespace)&lt;/code&gt;和&lt;code&gt;导入(Use)&lt;/code&gt;声明&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;code&gt;命名空间(namespace)&lt;/code&gt;的声明后面&lt;code&gt;必须&lt;/code&gt;有一行空行。&lt;/p&gt;

&lt;p&gt;所有的&lt;code&gt;导入(use)&lt;/code&gt;声明&lt;code&gt;必须&lt;/code&gt;放在&lt;code&gt;命名空间(namespace)&lt;/code&gt;声明的下面。&lt;/p&gt;

&lt;p&gt;一句声明中，&lt;code&gt;必须&lt;/code&gt;只有一个&lt;code&gt;导入(use)&lt;/code&gt;关键字。&lt;/p&gt;

&lt;p&gt;在&lt;code&gt;导入(use)&lt;/code&gt;声明代码块后面&lt;code&gt;必须&lt;/code&gt;有一行空行。&lt;/p&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;p&gt;```php
&amp;lt;?php
namespace Vendor\Package;&lt;/p&gt;

&lt;p&gt;use FooClass;
use BarClass as Bar;
use OtherVendor\OtherPackage\BazClass;&lt;/p&gt;

&lt;p&gt;// … 其它PHP代码 …&lt;/p&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;classpropertymethod&quot;&gt;&lt;code&gt;类(class)&lt;/code&gt;，&lt;code&gt;属性(property)&lt;/code&gt;和&lt;code&gt;方法(method)&lt;/code&gt;&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;术语“类”指所有的&lt;code&gt;类(class)&lt;/code&gt;，&lt;code&gt;接口(interface)&lt;/code&gt;和&lt;code&gt;特性(trait)&lt;/code&gt;。&lt;/p&gt;

&lt;h3 id=&quot;extendimplement&quot;&gt;4.1. &lt;code&gt;扩展(extend)&lt;/code&gt;和&lt;code&gt;实现(implement)&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;一个类的&lt;code&gt;扩展(extend)&lt;/code&gt;和&lt;code&gt;实现(implement)&lt;/code&gt;关键词&lt;code&gt;必须&lt;/code&gt;和&lt;code&gt;类名(class name)&lt;/code&gt;在同一行。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;类(class)&lt;/code&gt;的左花括号&lt;code&gt;必须&lt;/code&gt;放在下面自成一行；右花括号必须放在&lt;code&gt;类(class)&lt;/code&gt;主体的后面自成一行。&lt;/p&gt;

&lt;p&gt;```php
&amp;lt;?php
namespace Vendor\Package;&lt;/p&gt;

&lt;p&gt;use FooClass;
use BarClass as Bar;
use OtherVendor\OtherPackage\BazClass;&lt;/p&gt;

&lt;p&gt;class ClassName extends ParentClass implements \ArrayAccess, \Countable
{
    // 常量、属性、方法
}
```&lt;/p&gt;

&lt;p&gt;&lt;code&gt;实现(implement)&lt;/code&gt;列表&lt;code&gt;可以&lt;/code&gt;被拆分为多个缩进了一次的子行。如果要拆成多个子行，列表的第一项&lt;code&gt;必须&lt;/code&gt;要放在下一行，并且每行&lt;code&gt;必须&lt;/code&gt;只有一个&lt;code&gt;接口(interface)&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;```php
&amp;lt;?php
namespace Vendor\Package;&lt;/p&gt;

&lt;p&gt;use FooClass;
use BarClass as Bar;
use OtherVendor\OtherPackage\BazClass;&lt;/p&gt;

&lt;p&gt;class ClassName extends ParentClass implements
    \ArrayAccess,
    \Countable,
    \Serializable
{
    // 常量、属性、方法
}
```&lt;/p&gt;

&lt;h3 id=&quot;property&quot;&gt;4.2. &lt;code&gt;属性(property)&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;所有的&lt;code&gt;属性(property)&lt;/code&gt;都&lt;code&gt;必须&lt;/code&gt;声明其可见性。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;变量(var)&lt;/code&gt;关键字&lt;code&gt;不可&lt;/code&gt;用来声明一个&lt;code&gt;属性(property)&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;一条语句&lt;code&gt;不可&lt;/code&gt;声明多个&lt;code&gt;属性(property)&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;属性名(property name)&lt;/code&gt; &lt;code&gt;不推荐&lt;/code&gt;用单个下划线作为前缀来表明其&lt;code&gt;保护(protected)&lt;/code&gt;或&lt;code&gt;私有(private)&lt;/code&gt;的可见性。&lt;/p&gt;

&lt;p&gt;一个&lt;code&gt;属性(property)&lt;/code&gt;声明看起来应该像下面这样。&lt;/p&gt;

&lt;p&gt;```php
&amp;lt;?php
namespace Vendor\Package;&lt;/p&gt;

&lt;p&gt;class ClassName
{
    public $foo = null;
}
```&lt;/p&gt;

&lt;h3 id=&quot;method&quot;&gt;4.3. &lt;code&gt;方法(method)&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;所有的&lt;code&gt;方法(method)&lt;/code&gt;都&lt;code&gt;必须&lt;/code&gt;声明其可见性。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;方法名(method name)&lt;/code&gt; &lt;code&gt;不推荐&lt;/code&gt;用单个下划线作为前缀来表明其&lt;code&gt;保护(protected)&lt;/code&gt;或&lt;code&gt;私有(private)&lt;/code&gt;的可见性。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;方法名(method name)&lt;/code&gt;在其声明后面&lt;code&gt;不可&lt;/code&gt;有空格跟随。其左花括号&lt;code&gt;必须&lt;/code&gt;放在下面自成一行，且右花括号&lt;code&gt;必须&lt;/code&gt;放在方法主体的下面自成一行。左括号后面&lt;code&gt;不可&lt;/code&gt;有空格，且右括号前面也&lt;code&gt;不可&lt;/code&gt;有空格。&lt;/p&gt;

&lt;p&gt;一个&lt;code&gt;方法(method)&lt;/code&gt;声明看来应该像下面这样。 注意括号，逗号，空格和花括号的位置：&lt;/p&gt;

&lt;p&gt;```php
&amp;lt;?php
namespace Vendor\Package;&lt;/p&gt;

&lt;p&gt;class ClassName
{
    public function fooBarBaz($arg1, &amp;amp;$arg2, $arg3 = [])
    {
        // 方法主体部分
    }
}
```&lt;/p&gt;

&lt;h3 id=&quot;method-1&quot;&gt;4.4. &lt;code&gt;方法(method)&lt;/code&gt;的参数&lt;/h3&gt;

&lt;p&gt;在参数列表中，逗号之前&lt;code&gt;不可&lt;/code&gt;有空格，而逗号之后则&lt;code&gt;必须&lt;/code&gt;要有一个空格。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;方法(method)&lt;/code&gt;中有默认值的参数必须放在参数列表的最后面。&lt;/p&gt;

&lt;p&gt;```php
&amp;lt;?php
namespace Vendor\Package;&lt;/p&gt;

&lt;p&gt;class ClassName
{
    public function foo($arg1, &amp;amp;$arg2, $arg3 = [])
    {
        // 方法主体部分
    }
}
```&lt;/p&gt;

&lt;p&gt;参数列表&lt;code&gt;可以&lt;/code&gt;被拆分为多个缩进了一次的子行。如果要拆分成多个子行，参数列表的第一项&lt;code&gt;必须&lt;/code&gt;放在下一行，并且每行&lt;code&gt;必须&lt;/code&gt;只有一个参数。&lt;/p&gt;

&lt;p&gt;当参数列表被拆分成多个子行，右括号和左花括号之间&lt;code&gt;必须&lt;/code&gt;又一个空格并且自成一行。&lt;/p&gt;

&lt;p&gt;```php
&amp;lt;?php
namespace Vendor\Package;&lt;/p&gt;

&lt;p&gt;class ClassName
{
    public function aVeryLongMethodName(
        ClassTypeHint $arg1,
        &amp;amp;$arg2,
        array $arg3 = []
    ) {
        // 方法主体部分
    }
}
```&lt;/p&gt;

&lt;h3 id=&quot;abstractfinal-static&quot;&gt;4.5. &lt;code&gt;抽象(abstract)&lt;/code&gt;，&lt;code&gt;终结(final)&lt;/code&gt;和 &lt;code&gt;静态(static)&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;当用到&lt;code&gt;抽象(abstract)&lt;/code&gt;和&lt;code&gt;终结(final)&lt;/code&gt;来做类声明时，它们&lt;code&gt;必须&lt;/code&gt;放在可见性声明的前面。&lt;/p&gt;

&lt;p&gt;而当用到&lt;code&gt;静态(static)&lt;/code&gt;来做类声明时，则&lt;code&gt;必须&lt;/code&gt;放在可见性声明的后面。&lt;/p&gt;

&lt;p&gt;```php
&amp;lt;?php
namespace Vendor\Package;&lt;/p&gt;

&lt;p&gt;abstract class ClassName
{
    protected static $foo;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;abstract protected function zim();

final public static function bar()
{
    // 方法主体部分
} } ```
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-8&quot;&gt;4.6. 调用方法和函数&lt;/h3&gt;

&lt;p&gt;调用一个方法或函数时，在方法名或者函数名和左括号之间&lt;code&gt;不可&lt;/code&gt;有空格，左括号之后&lt;code&gt;不可&lt;/code&gt;有空格，右括号之前也&lt;code&gt;不可&lt;/code&gt;有空格。参数列表中，逗号之前&lt;code&gt;不可&lt;/code&gt;有空格，逗号之后则&lt;code&gt;必须&lt;/code&gt;有一个空格。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;php
&amp;lt;?php
bar();
$foo-&amp;gt;bar($arg1);
Foo::bar($arg2, $arg3);
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;参数列表&lt;code&gt;可以&lt;/code&gt;被拆分成多个缩进了一次的子行。如果拆分成子行，列表中的第一项&lt;code&gt;必须&lt;/code&gt;放在下一行，并且每一行&lt;code&gt;必须&lt;/code&gt;只能有一个参数。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;php
&amp;lt;?php
$foo-&amp;gt;bar(
    $longArgument,
    $longerArgument,
    $muchLongerArgument
);
&lt;/code&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;section-9&quot;&gt;控制结构&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;下面是对于控制结构代码风格的概括：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;控制结构的关键词之后&lt;code&gt;必须&lt;/code&gt;有一个空格。&lt;/li&gt;
  &lt;li&gt;控制结构的左括号之后&lt;code&gt;不可&lt;/code&gt;有空格。&lt;/li&gt;
  &lt;li&gt;控制结构的右括号之前&lt;code&gt;不可&lt;/code&gt;有空格。&lt;/li&gt;
  &lt;li&gt;控制结构的右括号和左花括号之间&lt;code&gt;必须&lt;/code&gt;有一个空格。&lt;/li&gt;
  &lt;li&gt;控制结构的代码主体&lt;code&gt;必须&lt;/code&gt;进行一次缩进。&lt;/li&gt;
  &lt;li&gt;控制结构的右花括号&lt;code&gt;必须&lt;/code&gt;主体的下一行。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;每个控制结构的代码主体&lt;code&gt;必须&lt;/code&gt;被括在花括号里。这样可是使代码看上去更加标准化，并且加入新代码的时候还可以因此而减少引入错误的可能性。&lt;/p&gt;

&lt;h3 id=&quot;ifelseifelse&quot;&gt;5.1. &lt;code&gt;if&lt;/code&gt;，&lt;code&gt;elseif&lt;/code&gt;，&lt;code&gt;else&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;下面是一个&lt;code&gt;if&lt;/code&gt;条件控制结构的示例，注意其中括号，空格和花括号的位置。同时注意&lt;code&gt;else&lt;/code&gt;和&lt;code&gt;elseif&lt;/code&gt;要和前一个条件控制结构的右花括号在同一行。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;php
&amp;lt;?php
if ($expr1) {
    // if body
} elseif ($expr2) {
    // elseif body
} else {
    // else body;
}
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;推荐&lt;/code&gt;用&lt;code&gt;elseif&lt;/code&gt;来替代&lt;code&gt;else if&lt;/code&gt;，以保持所有的条件控制关键字看起来像是一个单词。&lt;/p&gt;

&lt;h3 id=&quot;switchcase&quot;&gt;5.2. &lt;code&gt;switch&lt;/code&gt;，&lt;code&gt;case&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;下面是一个&lt;code&gt;switch&lt;/code&gt;条件控制结构的示例，注意其中括号，空格和花括号的位置。&lt;code&gt;case&lt;/code&gt;语句&lt;code&gt;必须&lt;/code&gt;要缩进一级，而&lt;code&gt;break&lt;/code&gt;关键字（或其他中止关键字）&lt;code&gt;必须&lt;/code&gt;和&lt;code&gt;case&lt;/code&gt;结构的代码主体在同一个缩进层级。如果一个有主体代码的&lt;code&gt;case&lt;/code&gt;结构故意的继续向下执行则&lt;code&gt;必须&lt;/code&gt;要有一个类似于&lt;code&gt;// no break&lt;/code&gt;的注释。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;php
&amp;lt;?php
switch ($expr) {
    case 0:
        echo &#39;First case, with a break&#39;;
        break;
    case 1:
        echo &#39;Second case, which falls through&#39;;
        // no break
    case 2:
    case 3:
    case 4:
        echo &#39;Third case, return instead of break&#39;;
        return;
    default:
        echo &#39;Default case&#39;;
        break;
}
&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;whiledo-while&quot;&gt;5.3. &lt;code&gt;while&lt;/code&gt;，&lt;code&gt;do while&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;下面是一个&lt;code&gt;while&lt;/code&gt;循环控制结构的示例，注意其中括号，空格和花括号的位置。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;php
&amp;lt;?php
while ($expr) {
    // structure body
}
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;下面是一个&lt;code&gt;do while&lt;/code&gt;循环控制结构的示例，注意其中括号，空格和花括号的位置。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;php
&amp;lt;?php
do {
    // structure body;
} while ($expr);
&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;for&quot;&gt;5.4. &lt;code&gt;for&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;下面是一个&lt;code&gt;for&lt;/code&gt;循环控制结构的示例，注意其中括号，空格和花括号的位置。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;php
&amp;lt;?php
for ($i = 0; $i &amp;lt; 10; $i++) {
    // for body
}
&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;foreach&quot;&gt;5.5. &lt;code&gt;foreach&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;下面是一个&lt;code&gt;foreach&lt;/code&gt;循环控制结构的示例，注意其中括号，空格和花括号的位置。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;php
&amp;lt;?php
foreach ($iterable as $key =&amp;gt; $value) {
    // foreach body
}
&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;try-catch&quot;&gt;5.6. &lt;code&gt;try&lt;/code&gt;, &lt;code&gt;catch&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;下面是一个&lt;code&gt;try catch&lt;/code&gt;异常处理控制结构的示例，注意其中括号，空格和花括号的位置。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;php
&amp;lt;?php
try {
    // try body
} catch (FirstExceptionType $e) {
    // catch body
} catch (OtherExceptionType $e) {
    // catch body
}
&lt;/code&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;section-10&quot;&gt;闭包&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;声明闭包时所用的&lt;code&gt;function&lt;/code&gt;关键字之后&lt;code&gt;必须&lt;/code&gt;要有一个空格，而&lt;code&gt;use&lt;/code&gt;关键字的前后都要有一个空格。&lt;/p&gt;

&lt;p&gt;闭包的左花括号&lt;code&gt;必须&lt;/code&gt;跟其在同一行，而右花括号&lt;code&gt;必须&lt;/code&gt;在闭包主体的下一行。&lt;/p&gt;

&lt;p&gt;闭包的参数列表和变量列表的左括号后面&lt;code&gt;不可&lt;/code&gt;有空格，右括号的前面也&lt;code&gt;不可&lt;/code&gt;有空格。&lt;/p&gt;

&lt;p&gt;闭包的参数列表和变量列表中逗号前面&lt;code&gt;不可&lt;/code&gt;有空格，而逗号后面则&lt;code&gt;必须&lt;/code&gt;有空格。&lt;/p&gt;

&lt;p&gt;闭包的参数列表中带默认值的参数&lt;code&gt;必须&lt;/code&gt;放在参数列表的结尾部分。&lt;/p&gt;

&lt;p&gt;下面是一个闭包的示例。注意括号，空格和花括号的位置。&lt;/p&gt;

&lt;p&gt;```php
&amp;lt;?php
$closureWithArgs = function ($arg1, $arg2) {
    // body
};&lt;/p&gt;

&lt;p&gt;$closureWithArgsAndVars = function ($arg1, $arg2) use ($var1, $var2) {
    // body
};
```&lt;/p&gt;

&lt;p&gt;参数列表和变量列表&lt;code&gt;可以&lt;/code&gt;被拆分成多个缩进了一级的子行。如果要拆分成多个子行，列表中的第一项&lt;code&gt;必须&lt;/code&gt;放在下一行，并且每一行&lt;code&gt;必须&lt;/code&gt;只放一个参数或变量。&lt;/p&gt;

&lt;p&gt;当列表（不管是参数还是变量）最终被拆分成多个子行，右括号和左花括号之间&lt;code&gt;必须&lt;/code&gt;要有一个空格并且自成一行。&lt;/p&gt;

&lt;p&gt;下面是一个参数列表和变量列表被拆分成多个子行的示例。&lt;/p&gt;

&lt;p&gt;```php
&amp;lt;?php
$longArgs_noVars = function (
    $longArgument,
    $longerArgument,
    $muchLongerArgument
) {
   // body
};&lt;/p&gt;

&lt;p&gt;$noArgs_longVars = function () use (
    $longVar1,
    $longerVar2,
    $muchLongerVar3
) {
   // body
};&lt;/p&gt;

&lt;p&gt;$longArgs_longVars = function (
    $longArgument,
    $longerArgument,
    $muchLongerArgument
) use (
    $longVar1,
    $longerVar2,
    $muchLongerVar3
) {
   // body
};&lt;/p&gt;

&lt;p&gt;$longArgs_shortVars = function (
    $longArgument,
    $longerArgument,
    $muchLongerArgument
) use ($var1) {
   // body
};&lt;/p&gt;

&lt;p&gt;$shortArgs_longVars = function ($arg) use (
    $longVar1,
    $longerVar2,
    $muchLongerVar3
) {
   // body
};
```&lt;/p&gt;

&lt;p&gt;把闭包作为一个参数在函数或者方法中调用时，依然要遵守上述规则。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;php
&amp;lt;?php
$foo-&amp;gt;bar(
    $arg1,
    function ($arg2) use ($var1) {
        // body
    },
    $arg3
);
&lt;/code&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;section-11&quot;&gt;结论&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;本指南有意的省略了许多元素的代码风格。主要包括：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;全局变量和全局常量的声明&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;函数声明&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;操作符和赋值&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;行间对齐&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;注释和文档块&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;类名的前缀和后缀&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;最佳实践&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;以后的代码规范中&lt;code&gt;可能&lt;/code&gt;会修正或扩展本指南中规定的代码风格。&lt;/p&gt;

&lt;h2 id=&quot;a-&quot;&gt;附录A 调查&lt;/h2&gt;

&lt;p&gt;为了写这个风格指南，我们调查了各个项目以最终确定通用的代码风格。并把这次调查在这里公布出来。&lt;/p&gt;

&lt;h3 id=&quot;a1-&quot;&gt;A.1. 调查数据&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;url,http://www.horde.org/apps/horde/docs/CODING_STANDARDS,http://pear.php.net/manual/en/standards.php,http://solarphp.com/manual/appendix-standards.style,http://framework.zend.com/manual/en/coding-standard.html,http://symfony.com/doc/2.0/contributing/code/standards.html,http://www.ppi.io/docs/coding-standards.html,https://github.com/ezsystems/ezp-next/wiki/codingstandards,http://book.cakephp.org/2.0/en/contributing/cakephp-coding-conventions.html,https://github.com/UnionOfRAD/lithium/wiki/Spec%3A-Coding,http://drupal.org/coding-standards,http://code.google.com/p/sabredav/,http://area51.phpbb.com/docs/31x/coding-guidelines.html,https://docs.google.com/a/zikula.org/document/edit?authkey=CPCU0Us&amp;amp;hgd=1&amp;amp;id=1fcqb93Sn-hR9c0mkN6m_tyWnmEvoswKBtSc0tKkZmJA,http://www.chisimba.com,n/a,https://github.com/Respect/project-info/blob/master/coding-standards-sample.php,n/a,Object Calisthenics for PHP,http://doc.nette.org/en/coding-standard,http://flow3.typo3.org,https://github.com/propelorm/Propel2/wiki/Coding-Standards,http://developer.joomla.org/coding-standards.html
voting,yes,yes,yes,yes,yes,yes,yes,yes,yes,yes,yes,yes,yes,yes,yes,no,no,no,?,yes,no,yes
indent_type,4,4,4,4,4,tab,4,tab,tab,2,4,tab,4,4,4,4,4,4,tab,tab,4,tab
line_length_limit_soft,75,75,75,75,no,85,120,120,80,80,80,no,100,80,80,?,?,120,80,120,no,150
line_length_limit_hard,85,85,85,85,no,no,no,no,100,?,no,no,no,100,100,?,120,120,no,no,no,no
class_names,studly,studly,studly,studly,studly,studly,studly,studly,studly,studly,studly,lower_under,studly,lower,studly,studly,studly,studly,?,studly,studly,studly
class_brace_line,next,next,next,next,next,same,next,same,same,same,same,next,next,next,next,next,next,next,next,same,next,next
constant_names,upper,upper,upper,upper,upper,upper,upper,upper,upper,upper,upper,upper,upper,upper,upper,upper,upper,upper,upper,upper,upper,upper
true_false_null,lower,lower,lower,lower,lower,lower,lower,lower,lower,upper,lower,lower,lower,upper,lower,lower,lower,lower,lower,upper,lower,lower
method_names,camel,camel,camel,camel,camel,camel,camel,camel,camel,camel,camel,lower_under,camel,camel,camel,camel,camel,camel,camel,camel,camel,camel
method_brace_line,next,next,next,next,next,same,next,same,same,same,same,next,next,same,next,next,next,next,next,same,next,next
control_brace_line,same,same,same,same,same,same,next,same,same,same,same,next,same,same,next,same,same,same,same,same,same,next
control_space_after,yes,yes,yes,yes,yes,no,yes,yes,yes,yes,no,yes,yes,yes,yes,yes,yes,yes,yes,yes,yes,yes
always_use_control_braces,yes,yes,yes,yes,yes,yes,no,yes,yes,yes,no,yes,yes,yes,yes,no,yes,yes,yes,yes,yes,yes
else_elseif_line,same,same,same,same,same,same,next,same,same,next,same,next,same,next,next,same,same,same,same,same,same,next
case_break_indent_from_switch,0/1,0/1,0/1,1/2,1/2,1/2,1/2,1/1,1/1,1/2,1/2,1/1,1/2,1/2,1/2,1/2,1/2,1/2,0/1,1/1,1/2,1/2
function_space_after,no,no,no,no,no,no,no,no,no,no,no,no,no,no,no,no,no,no,no,no,no,no
closing_php_tag_required,no,no,no,no,no,no,no,no,yes,no,no,no,no,yes,no,no,no,no,no,yes,no,no
line_endings,LF,LF,LF,LF,LF,LF,LF,LF,?,LF,?,LF,LF,LF,LF,?,,LF,?,LF,LF,LF
static_or_visibility_first,static,?,static,either,either,either,visibility,visibility,visibility,either,static,either,?,visibility,?,?,either,either,visibility,visibility,static,?
control_space_parens,no,no,no,no,no,no,yes,no,no,no,no,no,no,yes,?,no,no,no,no,no,no,no
blank_line_after_php,no,no,no,no,yes,no,no,no,no,yes,yes,no,no,yes,?,yes,yes,no,yes,no,yes,no
class_method_control_brace,next/next/same,next/next/same,next/next/same,next/next/same,next/next/same,same/same/same,next/next/next,same/same/same,same/same/same,same/same/same,same/same/same,next/next/next,next/next/same,next/same/same,next/next/next,next/next/same,next/next/same,next/next/same,next/next/same,same/same/same,next/next/same,next/next/next
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;a2-&quot;&gt;A.2. 调查说明&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;indent_type&lt;/code&gt;:
缩进类型。 &lt;code&gt;tab&lt;/code&gt; = “使用制表符”，&lt;code&gt;2&lt;/code&gt; or &lt;code&gt;4&lt;/code&gt; = “空格数量”&lt;/p&gt;

&lt;p&gt;&lt;code&gt;line_length_limit_soft&lt;/code&gt;:
行长度的“软”限制，用字符。 &lt;code&gt;?&lt;/code&gt; = 不表示或者数字 &lt;code&gt;no&lt;/code&gt; 意为不限制.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;line_length_limit_hard&lt;/code&gt;:
行长度的”硬”限制，用字符。 &lt;code&gt;?&lt;/code&gt; = 不表示或者数字, &lt;code&gt;no&lt;/code&gt; 意为不限制.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;class_names&lt;/code&gt;:
类名如何命名 &lt;code&gt;lower&lt;/code&gt; = 只是小写, &lt;code&gt;lower_under&lt;/code&gt; = 小写加下划线, &lt;code&gt;studly&lt;/code&gt; = 骆驼型.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;class_brace_line&lt;/code&gt;:
类的左花括号是放在同(&lt;code&gt;same&lt;/code&gt;)一行还是在下(&lt;code&gt;next&lt;/code&gt;)一行？&lt;/p&gt;

&lt;p&gt;&lt;code&gt;constant_names&lt;/code&gt;:
类常量如何命名？&lt;code&gt;upper&lt;/code&gt; = 大写加下划线分隔符。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;true_false_null&lt;/code&gt;:
全小写或者全大写？&lt;/p&gt;

&lt;p&gt;&lt;code&gt;method_names&lt;/code&gt;:
方法名如何命名？&lt;code&gt;camel&lt;/code&gt; = &lt;code&gt;驼峰式&lt;/code&gt;, &lt;code&gt;lower_under&lt;/code&gt; = 小写加下划线分隔符。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;method_brace_line&lt;/code&gt;:
方法的左花括号在同(&lt;code&gt;same&lt;/code&gt;)一行还是在下(&lt;code&gt;next&lt;/code&gt;)一行？&lt;/p&gt;

&lt;p&gt;&lt;code&gt;control_brace_line&lt;/code&gt;:
控制结构的左花括号在同(&lt;code&gt;same&lt;/code&gt;)一行还是在下(&lt;code&gt;next&lt;/code&gt;)一行？&lt;/p&gt;

&lt;p&gt;&lt;code&gt;control_space_after&lt;/code&gt;:
控制结构关键词后是否有空格？&lt;/p&gt;

&lt;p&gt;&lt;code&gt;always_use_control_braces&lt;/code&gt;:
控制结构总是使用花括号？&lt;/p&gt;

&lt;p&gt;&lt;code&gt;else_elseif_line&lt;/code&gt;:
当使用&lt;code&gt;else&lt;/code&gt;和&lt;code&gt;elseif&lt;/code&gt;，是否放在同(&lt;code&gt;same&lt;/code&gt;)一行还是在下(&lt;code&gt;next&lt;/code&gt;)一行？&lt;/p&gt;

&lt;p&gt;&lt;code&gt;case_break_indent_from_switch&lt;/code&gt;:
&lt;code&gt;case&lt;/code&gt;和&lt;code&gt;break&lt;/code&gt;分别从&lt;code&gt;swith&lt;/code&gt;语句处缩进多少次？&lt;/p&gt;

&lt;p&gt;&lt;code&gt;function_space_after&lt;/code&gt;:
函数调用的函数名和左括号是否有空格？&lt;/p&gt;

&lt;p&gt;&lt;code&gt;closing_php_tag_required&lt;/code&gt;:
如过是纯PHP文件，关闭标签&lt;code&gt;?&amp;gt;&lt;/code&gt;是否需要？&lt;/p&gt;

&lt;p&gt;&lt;code&gt;line_endings&lt;/code&gt;:
使用何种的行结束符？&lt;/p&gt;

&lt;p&gt;&lt;code&gt;static_or_visibility_first&lt;/code&gt;:
在定义方法的时候&lt;code&gt;static&lt;/code&gt;和可见性谁在前面？&lt;/p&gt;

&lt;p&gt;&lt;code&gt;control_space_parens&lt;/code&gt;:
在控制结构表达式中，左括号后面和右括号前面是否要有一个空格？&lt;code&gt;yes&lt;/code&gt; = &lt;code&gt;if ( $expr )&lt;/code&gt;, &lt;code&gt;no&lt;/code&gt; = &lt;code&gt;if ($expr)&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;blank_line_after_php&lt;/code&gt;:
PHP的开始标签后面是否需要一个空行？&lt;/p&gt;

&lt;p&gt;&lt;code&gt;class_method_control_brace&lt;/code&gt;:
左花括号在类，方法和控制结构中的位置。&lt;/p&gt;

&lt;h3 id=&quot;a3-&quot;&gt;A.3. 调查结果&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;indent_type:
    tab: 7
    2: 1
    4: 14
line_length_limit_soft:
    ?: 2
    no: 3
    75: 4
    80: 6
    85: 1
    100: 1
    120: 4
    150: 1
line_length_limit_hard:
    ?: 2
    no: 11
    85: 4
    100: 3
    120: 2
class_names:
    ?: 1
    lower: 1
    lower_under: 1
    studly: 19
class_brace_line:
    next: 16
    same: 6
constant_names:
    upper: 22
true_false_null:
    lower: 19
    upper: 3
method_names:
    camel: 21
    lower_under: 1
method_brace_line:
    next: 15
    same: 7
control_brace_line:
    next: 4
    same: 18
control_space_after:
    no: 2
    yes: 20
always_use_control_braces:
    no: 3
    yes: 19
else_elseif_line:
    next: 6
    same: 16
case_break_indent_from_switch:
    0/1: 4
    1/1: 4
    1/2: 14
function_space_after:
    no: 22
closing_php_tag_required:
    no: 19
    yes: 3
line_endings:
    ?: 5
    LF: 17
static_or_visibility_first:
    ?: 5
    either: 7
    static: 4
    visibility: 6
control_space_parens:
    ?: 1
    no: 19
    yes: 2
blank_line_after_php:
    ?: 1
    no: 13
    yes: 8
class_method_control_brace:
    next/next/next: 4
    next/next/same: 11
    next/same/same: 1
    same/same/same: 6
&lt;/code&gt;&lt;/pre&gt;
</content>
 </entry>
 
 <entry>
   <title>PSR1代码规范1</title>
   <link href="https://zhuiyi1997.github.io//2016/10/16/psr1.html"/>
   <updated>2016-10-16T00:00:00+08:00</updated>
   <id>urn:uuid:b87da13a-a4dd-402f-b06a-cef7eeee2d80</id>
   <content type="html">&lt;h1 id=&quot;section&quot;&gt;基本代码规范&lt;/h1&gt;

&lt;p&gt;本节我们将会讨论一些基本的代码规范问题，以此作为将来讨论更高级别的代码分享和技术互用的基础。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc2119.txt&quot;&gt;RFC 2119&lt;/a&gt;中的&lt;code&gt;必须(MUST)&lt;/code&gt;，&lt;code&gt;不可(MUST NOT)&lt;/code&gt;，&lt;code&gt;建议(SHOULD)&lt;/code&gt;，&lt;code&gt;不建议(SHOULD NOT)&lt;/code&gt;，&lt;code&gt;可以/可能(MAY)&lt;/code&gt;等关键词将在本节用来做一些解释性的描述。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;section-1&quot;&gt;概述&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;源文件&lt;code&gt;必须&lt;/code&gt;只使用 &lt;code&gt;&amp;lt;?php&lt;/code&gt; 和 &lt;code&gt;&amp;lt;?=&lt;/code&gt; 这两种标签。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;源文件中php代码的编码格式&lt;code&gt;必须&lt;/code&gt;只使用不带&lt;code&gt;字节顺序标记(BOM)&lt;/code&gt;的&lt;code&gt;UTF-8&lt;/code&gt;。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;一个源文件&lt;code&gt;建议&lt;/code&gt;只用来做声明（&lt;code&gt;类(class)&lt;/code&gt;，&lt;code&gt;函数(function)&lt;/code&gt;，&lt;code&gt;常量(constant)&lt;/code&gt;等）或者只用来做一些引起副作用的操作（例如：输出信息，修改&lt;code&gt;.ini&lt;/code&gt;配置等）,但&lt;code&gt;不建议&lt;/code&gt;同时做这两件事。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code&gt;命名空间(namespace)&lt;/code&gt;和&lt;code&gt;类(class)&lt;/code&gt; &lt;code&gt;必须&lt;/code&gt;遵守&lt;a href=&quot;https://github.com/hfcorriez/fig-standards/blob/zh_CN/接受/PSR-0.md&quot;&gt;PSR-0&lt;/a&gt;标准。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code&gt;类名(class name)&lt;/code&gt; &lt;code&gt;必须&lt;/code&gt;使用&lt;code&gt;骆驼式(StudlyCaps)&lt;/code&gt;写法 (译者注：&lt;code&gt;驼峰式(cameCase)&lt;/code&gt;的一种变种，后文将直接用&lt;code&gt;StudlyCaps&lt;/code&gt;表示)。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code&gt;类(class)&lt;/code&gt;中的常量&lt;code&gt;必须&lt;/code&gt;只由大写字母和&lt;code&gt;下划线(_)&lt;/code&gt;组成。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code&gt;方法名(method name)&lt;/code&gt; &lt;code&gt;必须&lt;/code&gt;使用&lt;code&gt;驼峰式(cameCase)&lt;/code&gt;写法(译者注：后文将直接用&lt;code&gt;camelCase&lt;/code&gt;表示)。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;section-2&quot;&gt;文件&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;php&quot;&gt;2.1. PHP标签&lt;/h3&gt;

&lt;p&gt;PHP代码&lt;code&gt;必须&lt;/code&gt;只使用&lt;code&gt;长标签(&amp;lt;?php ?&amp;gt;)&lt;/code&gt;或者&lt;code&gt;短输出式标签(&amp;lt;?= ?&amp;gt;)&lt;/code&gt;；而&lt;code&gt;不可&lt;/code&gt;使用其他标签。&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;2.2. 字符编码&lt;/h3&gt;

&lt;p&gt;PHP代码的编码格式&lt;code&gt;必须&lt;/code&gt;只使用不带&lt;code&gt;字节顺序标记(BOM)&lt;/code&gt;的&lt;code&gt;UTF-8&lt;/code&gt;。&lt;/p&gt;

&lt;h3 id=&quot;section-4&quot;&gt;2.3. 副作用&lt;/h3&gt;

&lt;p&gt;一个源文件&lt;code&gt;建议&lt;/code&gt;只用来做声明（&lt;code&gt;类(class)&lt;/code&gt;，&lt;code&gt;函数(function)&lt;/code&gt;，&lt;code&gt;常量(constant)&lt;/code&gt;等）或者只用来做一些引起副作用的操作（例如：输出信息，修改&lt;code&gt;.ini&lt;/code&gt;配置等）,但&lt;code&gt;不建议&lt;/code&gt;同时做这两件事。&lt;/p&gt;

&lt;p&gt;短语&lt;code&gt;副作用(side effects)&lt;/code&gt;的意思是 &lt;em&gt;在包含文件时&lt;/em&gt; 所执行的逻辑与所声明的&lt;code&gt;类(class)&lt;/code&gt;，&lt;code&gt;函数(function)&lt;/code&gt;，&lt;code&gt;常量(constant)&lt;/code&gt;等没有直接的关系。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;副作用(side effects)&lt;/code&gt;包含但不局限于：产生输出，显式地使用&lt;code&gt;require&lt;/code&gt;或&lt;code&gt;include&lt;/code&gt;，连接外部服务，修改ini配置，触发错误或异常，修改全局或者静态变量，读取或修改文件等等&lt;/p&gt;

&lt;p&gt;下面是一个既包含声明又有副作用的示例文件；即应避免的例子：&lt;/p&gt;

&lt;p&gt;```php
&amp;lt;?php
// 副作用：修改了ini配置
ini_set(‘error_reporting’, E_ALL);&lt;/p&gt;

&lt;p&gt;// 副作用：载入了文件
include “file.php”;&lt;/p&gt;

&lt;p&gt;// 副作用：产生了输出
echo “&amp;lt;html&amp;gt;\n”;&lt;/p&gt;

&lt;p&gt;// 声明
function foo()
{
    // 函数体
}
```&lt;/p&gt;

&lt;p&gt;下面是一个仅包含声明的示例文件；即应提倡的例子：&lt;/p&gt;

&lt;p&gt;```php
&amp;lt;?php
// 声明
function foo()
{
    // 函数体
}&lt;/p&gt;

&lt;p&gt;// 条件式声明不算做是副作用
if (! function_exists(‘bar’)) {
    function bar()
    {
        // 函数体
    }
}
```&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;namespaceclass-name&quot;&gt;&lt;code&gt;空间名(namespace)&lt;/code&gt;和&lt;code&gt;类名(class name)&lt;/code&gt;&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;code&gt;命名空间(namespace)&lt;/code&gt;和&lt;code&gt;类(class)&lt;/code&gt;必须遵守 &lt;a href=&quot;https://github.com/hfcorriez/fig-standards/blob/zh_CN/接受/PSR-0.md&quot;&gt;PSR-0&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;这意味着一个源文件中只能有一个&lt;code&gt;类(class)&lt;/code&gt;，并且每个&lt;code&gt;类(class)&lt;/code&gt;至少要有一级&lt;code&gt;空间名（namespace）&lt;/code&gt;：即一个顶级的&lt;code&gt;组织名(vendor name)&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;类名(class name)&lt;/code&gt; &lt;code&gt;必须&lt;/code&gt;使用&lt;code&gt;StudlyCaps&lt;/code&gt;写法。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;PHP5.3&lt;/code&gt;之后的代码&lt;code&gt;必须&lt;/code&gt;使用正式的&lt;code&gt;命名空间(namespace)&lt;/code&gt;
例子：&lt;/p&gt;

&lt;p&gt;```php
&amp;lt;?php
// PHP 5.3 及之后:
namespace Vendor\Model;&lt;/p&gt;

&lt;p&gt;class Foo
{
}
```&lt;/p&gt;

&lt;p&gt;&lt;code&gt;PHP5.2.x&lt;/code&gt;之前的代码&lt;code&gt;建议&lt;/code&gt;用伪命名空间&lt;code&gt;Vendor_&lt;/code&gt;作为&lt;code&gt;类名(class name)&lt;/code&gt;的前缀&lt;/p&gt;

&lt;p&gt;&lt;code&gt;php
&amp;lt;?php
// PHP 5.2.x 及之前:
class Vendor_Model_Foo
{
}
&lt;/code&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;section-5&quot;&gt;类的常量、属性和方法&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;术语&lt;code&gt;类(class)&lt;/code&gt;指所有的&lt;code&gt;类(class)&lt;/code&gt;，&lt;code&gt;接口(interface)&lt;/code&gt;和&lt;code&gt;特性(trait)&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-6&quot;&gt;4.1. 常量&lt;/h3&gt;

&lt;p&gt;类常量&lt;code&gt;必须&lt;/code&gt;只由大写字母和&lt;code&gt;下划线(_)&lt;/code&gt;组成。
例子：&lt;/p&gt;

&lt;p&gt;```php
&amp;lt;?php
namespace Vendor\Model;&lt;/p&gt;

&lt;p&gt;class Foo
{
    const VERSION = ‘1.0’;
    const DATE_APPROVED = ‘2012-06-01’;
}
```&lt;/p&gt;

&lt;h3 id=&quot;section-7&quot;&gt;4.2. 属性&lt;/h3&gt;

&lt;p&gt;本指南中故意不对&lt;code&gt;$StulyCaps&lt;/code&gt;，&lt;code&gt;$camelCase&lt;/code&gt;或者&lt;code&gt;$unser_score&lt;/code&gt;中的某一种风格作特别推荐，完全由读者依据个人喜好决定属性名的命名风格。&lt;/p&gt;

&lt;p&gt;但是不管你如何定义属性名，&lt;code&gt;建议&lt;/code&gt;在一个合理的范围内保持一致。这个范围可能是&lt;code&gt;组织(vendor)&lt;/code&gt;级别的，&lt;code&gt;包(package)&lt;/code&gt;级别的，&lt;code&gt;类(class)&lt;/code&gt;级别的，或者&lt;code&gt;方法(method)&lt;/code&gt;级别的。&lt;/p&gt;

&lt;h3 id=&quot;section-8&quot;&gt;4.3. 方法&lt;/h3&gt;

&lt;p&gt;方法名则&lt;code&gt;必须&lt;/code&gt;使用&lt;code&gt;camelCase()&lt;/code&gt;风格来声明。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>PSR1代码规范0</title>
   <link href="https://zhuiyi1997.github.io//2016/10/16/psr0.html"/>
   <updated>2016-10-16T00:00:00+08:00</updated>
   <id>urn:uuid:b87da13a-a4dd-402f-b06a-cef7eeee2d80</id>
   <content type="html">&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;已弃用&lt;/strong&gt; - 截止到2014年10月21日，PSR-0已被弃用。 推荐替代使用&lt;a href=&quot;http://www.php-fig.org/psr/psr-4/&quot;&gt;PSR-4&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;下文描述了若要使用一个通用的&lt;code&gt;自动加载器(autoloader)&lt;/code&gt;，你所需要遵守的规范：&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;规范&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;一个完全标准的&lt;code&gt;命名空间(namespace)&lt;/code&gt;和&lt;code&gt;类(class)&lt;/code&gt;的结构是这样的：&lt;code&gt;\&amp;lt;Vendor Name&amp;gt;\(&amp;lt;Namespace&amp;gt;\)*&amp;lt;Class Name&amp;gt;&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;每个&lt;code&gt;命名空间(namespace)&lt;/code&gt;都必须有一个顶级的&lt;code&gt;空间名(namespace)&lt;/code&gt;(“&lt;code&gt;组织名(Vendor Name)&lt;/code&gt;”)。&lt;/li&gt;
  &lt;li&gt;每个&lt;code&gt;命名空间(namespace)&lt;/code&gt;中可以根据需要使用任意数量的&lt;code&gt;子命名空间(sub-namespace)&lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;从文件系统中加载源文件时，&lt;code&gt;空间名(namespace)&lt;/code&gt;中的分隔符将被转换为 &lt;code&gt;DIRECTORY_SEPARATOR&lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;类名(class name)&lt;/code&gt;中的每个下划线&lt;code&gt;_&lt;/code&gt;都将被转换为一个&lt;code&gt;DIRECTORY_SEPARATOR&lt;/code&gt;。下划线&lt;code&gt;_&lt;/code&gt;在&lt;code&gt;空间名(namespace)&lt;/code&gt;中没有什么特殊的意义。&lt;/li&gt;
  &lt;li&gt;完全标准的&lt;code&gt;命名空间(namespace)&lt;/code&gt;和&lt;code&gt;类(class)&lt;/code&gt;从文件系统加载源文件时将会加上&lt;code&gt;.php&lt;/code&gt;后缀。&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;组织名(vendor name)&lt;/code&gt;，&lt;code&gt;空间名(namespace)&lt;/code&gt;，&lt;code&gt;类名(class name)&lt;/code&gt;都由大小写字母组合而成。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-1&quot;&gt;示例&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;\Doctrine\Common\IsolatedClassLoader&lt;/code&gt; =&amp;gt; &lt;code&gt;/path/to/project/lib/vendor/Doctrine/Common/IsolatedClassLoader.php&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;\Symfony\Core\Request&lt;/code&gt; =&amp;gt; &lt;code&gt;/path/to/project/lib/vendor/Symfony/Core/Request.php&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;\Zend\Acl&lt;/code&gt; =&amp;gt; &lt;code&gt;/path/to/project/lib/vendor/Zend/Acl.php&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;\Zend\Mail\Message&lt;/code&gt; =&amp;gt; &lt;code&gt;/path/to/project/lib/vendor/Zend/Mail/Message.php&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;namespaceclass-name&quot;&gt;&lt;code&gt;空间名(namespace)&lt;/code&gt;和&lt;code&gt;类名(class name)&lt;/code&gt;中的下划线&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;\namespace\package\Class_Name&lt;/code&gt; =&amp;gt; &lt;code&gt;/path/to/project/lib/vendor/namespace/package/Class/Name.php&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;\namespace\package_name\Class_Name&lt;/code&gt; =&amp;gt; &lt;code&gt;/path/to/project/lib/vendor/namespace/package_name/Class/Name.php&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;以上是我们为实现通用的自动加载而制定的最低标准。你可以利用能够自动加载&lt;code&gt;PHP 5.3&lt;/code&gt;类的&lt;code&gt;SplClassLoader&lt;/code&gt;来测试你的代码是否符合这些标准。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;实例&lt;/h2&gt;

&lt;p&gt;下面是一个怎样利用上述标准来实现自动加载的示例函数。&lt;/p&gt;

&lt;p&gt;```php
&amp;lt;?php&lt;/p&gt;

&lt;p&gt;function autoload($className)
{
    $className = ltrim($className, ‘\’);
    $fileName  = ‘’;
    $namespace = ‘’;
    if ($lastNsPos = strrpos($className, ‘\’)) {
        $namespace = substr($className, 0, $lastNsPos);
        $className = substr($className, $lastNsPos + 1);
        $fileName  = str_replace(‘\’, DIRECTORY_SEPARATOR, $namespace) . DIRECTORY_SEPARATOR;
    }
    $fileName .= str_replace(‘_’, DIRECTORY_SEPARATOR, $className) . ‘.php’;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;require $fileName; } ```
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;splclassloader&quot;&gt;&lt;code&gt;SplClassLoader&lt;/code&gt;实现&lt;/h2&gt;

&lt;p&gt;下面的gist是一个按照上面建议的标准来自动加载类的&lt;code&gt;SplClassLoader&lt;/code&gt;实例。这是依据这些标准来加载&lt;code&gt;PHP 5.3&lt;/code&gt;类的推荐方案。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://gist.github.com/221634&quot;&gt;http://gist.github.com/221634&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</content>
 </entry>
 
 <entry>
   <title>浅谈MVC架构模式分析与设计</title>
   <link href="https://zhuiyi1997.github.io//2016/09/01/mvc-talk-lightly.html"/>
   <updated>2016-09-01T00:00:00+08:00</updated>
   <id>urn:uuid:b87da13a-a4dd-402f-b06a-cef7eeee2d80</id>
   <content type="html">&lt;hr /&gt;

&lt;!-- more --&gt;

&lt;p&gt;MVC全名是Model View Controller ,是模型-视图-控制器的缩写。&lt;/p&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;p&gt;视图：我们能能直观的看到的web界面。&lt;/p&gt;

&lt;p&gt;控制器：向系统发出指令的工具和帮手。&lt;/p&gt;

&lt;p&gt;模型：模型的工作是按要求从数据库取出数据。&lt;/p&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;p&gt;学习MVC的目的：&lt;/p&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;p&gt;1、快速上手各大主流PHP框架，列如YII框架、thinkphp、ci等&lt;/p&gt;

&lt;p&gt;2、快速适应多数公司的web开发需求&lt;/p&gt;

&lt;p&gt;3、逐步接触和了解web系统架构的知识、为日后成为系统架构的中坚力量做准备&lt;/p&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;p&gt;MVC解决的问题：&lt;/p&gt;

&lt;p&gt;```
在PHP还不支持面向对象之前，是过程化的方式来创建的，它们将 Model View Controller 三层的代码混在一起，十分混乱。&lt;/p&gt;

&lt;p&gt;它解决的问题有：维护难、开发速度慢、二次开发难度高，工作量大&lt;/p&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;p&gt;MVC的优势：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/res/img/blog/PHP学习/MVC_1.jpg&quot; alt=&quot;MVC_1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;MVC的工作流程初步认识：&lt;/p&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;p&gt;1、浏览者 -&amp;gt; 调用控制器，对它发出指令
2、控制器 -&amp;gt; 按指令选取一个合适的模型
3、模型 -&amp;gt; 安控制器指令去相应数据
4、控制器 -&amp;gt; 按指令选取相应视图
5、视图 -&amp;gt; 把第三步取到的数据按用户想要的样子显示出来&lt;/p&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;p&gt;NVC的目录结构：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/res/img/blog/PHP学习/MVC_2.jpg&quot; alt=&quot;MVC_2&quot; /&gt;&lt;/p&gt;
</content>
 </entry>
 
 
</feed>
