<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 
 <title>世间自古有情痴</title>
 <link href="https://zhuiyi1997.github.io//atom.xml" rel="self"/>
 <link href="https://zhuiyi1997.github.io/"/>
 <updated>2016-12-05T11:14:40+08:00</updated>
 <id>https://zhuiyi1997.github.io//</id>
 <author>
   <name>追憶</name>
 </author>

 
 <entry>
   <title>openssl进行非对称加密和对称加密的php示例</title>
   <link href="https://zhuiyi1997.github.io//2016/12/05/jiami.html"/>
   <updated>2016-12-05T00:00:00+08:00</updated>
   <id>urn:uuid:b87da13a-a4dd-402f-b06a-cef7eeee2d80</id>
   <content type="html">&lt;p&gt;确保开启PHP的openssl扩展：extension=php_openssl.dll&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?php
/**
 * @file
 * 作者：yunke url：http://blog.csdn.net/u011474028
 *
 */
header(&quot;Content-Type:text/html; charset=utf-8&quot;);

$key_file = &quot;yunkeserver.key&quot;; //私钥
$publickey_file = &quot;yunkeserver.crt&quot;; //证书文件
//$publickey_file=&quot;server.crt&quot;;//和私钥不匹配的证书文件
$data_file = &quot;msg.txt&quot;; //待加密数据文件

$private_key = openssl_get_privatekey(file_get_contents($key_file)); //获取私钥 非字符串类型  为资源类型
echo &quot;私钥为：&amp;lt;br&amp;gt;&quot; . $private_key . &quot;&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;&quot;;
$public_key = openssl_get_publickey(file_get_contents($publickey_file)); //获取公钥 非字符串类型  为资源类型
echo &quot;公钥为：&amp;lt;br&amp;gt;&quot; . $public_key . &quot;&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;&quot;;

/*
$str_key = &#39;&#39;; //KEY的字符串表示
if (openssl_pkey_export($private_key, $str_key)) { //需要正确配置openssl.cnf文件才可以成功
    echo &quot;密钥的字符串表示为：&amp;lt;br&amp;gt;&quot; . $str_key . &quot;&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;&quot;;
} else {
    echo &quot;密钥的字符串化失败：&amp;lt;br&amp;gt;&quot;;
    while ($msg = openssl_error_string()) {
        echo $msg . &quot;&amp;lt;br /&amp;gt;\n&quot;;
    }
    echo &quot;&amp;lt;br /&amp;gt;&quot;;
}
*/
 //print_r(openssl_pkey_get_details ( $public_key )); //输出密钥的详细信息 这里可以看出私钥里面是包含公钥的

$data = file_get_contents($data_file);
echo &quot;明码数据为：&amp;lt;br&amp;gt;&quot; . $data . &quot;&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;&quot;;

$crypted_data = null; //密文
if (openssl_private_encrypt($data, $crypted_data, $private_key)) {
    echo &quot;以下是私钥加密的密文：&amp;lt;br&amp;gt;&quot; . $crypted_data . &quot;&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;&quot;;
} else {
    echo &quot;加密失败：&amp;lt;br&amp;gt;&quot;;
    while ($msg = openssl_error_string()) {
        echo $msg . &quot;&amp;lt;br /&amp;gt;\n&quot;;
    }
}
$decrypted_data = null; //加密还原后的明文
if (openssl_public_decrypt($crypted_data, $decrypted_data, $public_key)) {
    echo &quot;以下是经过公钥解密后的明文：&amp;lt;br&amp;gt;&quot; . $decrypted_data . &quot;&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;&quot;;
} else {
    echo &quot;解密失败：&amp;lt;br&amp;gt;&quot;;
    while ($msg = openssl_error_string()) {
        echo $msg . &quot;&amp;lt;br /&amp;gt;\n&quot;;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;//以上为非对称加密   以下演示对称加密&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$key=&quot;123456&quot;; //设置一个共享密码
$cipher=&#39;&#39;;//加密算法
$arr=openssl_get_cipher_methods(); //获取支持的加密算法 数组的key和值并没有对应关系
$cipher=$arr[20];
echo &quot;选择的加密算法是：$cipher &amp;lt;br&amp;gt;\n&quot;;
$value=openssl_encrypt($data , $cipher,$key); //第四参数OPENSSL_RAW_DATA输出原始数据 
echo &quot;加密后的密文是：&amp;lt;br&amp;gt;&quot;.$value.&quot;&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;&quot;;
$old_data=openssl_decrypt ( $value,$cipher, $key);
echo &quot;解密还原的明文：&amp;lt;br&amp;gt;&quot;.$old_data.&quot;&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;&quot;;

//print_r($arr);
&lt;/code&gt;&lt;/pre&gt;
</content>
 </entry>
 
 <entry>
   <title>我的简历</title>
   <link href="https://zhuiyi1997.github.io//2016/12/04/jianli.html"/>
   <updated>2016-12-04T00:00:00+08:00</updated>
   <id>urn:uuid:b87da13a-a4dd-402f-b06a-cef7eeee2d80</id>
   <content type="html">&lt;p&gt;个人概况&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;姓    名：袁天赐                             	性    别：男
户    口：河南南阳                                	婚    否：未婚
工  作  经 验：2年                                    手    机：17600167516
电子邮箱：fengfeisanfa@163.com    现居住地：北京昌平
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;自我评价&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1、乐观开朗，对待工作认真负责,具有强烈的责任感.
2、做事前先制定好整体流程，分析所利用技术点，然后一步一步踏实完成.
3、工作中喜欢钻研一些模块的技术难点，比较喜欢解决后的愉快感觉.
4、拥有良好的代码编程习惯和排错能力.
5、喜欢学习，乐于助人，踏实勤劳.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;求职意向&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;工作性质：全职
期望职业: PHP开发工程师
期望行业：互联网
工作地区：北京
期望月薪：15K
目前状况：我目前处于离职状态，可立即上岗
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;专业技能&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1、熟悉mvc编程思想.
2、熟悉tp框架.也使用过ci、laravel框架. 
3、熟悉linux基本操作命令，能在apache或nginx下搭建应用，配置各种重写规则.(分三个级别，定向错误页面，使用伪静态)
4、掌握mysql基本常用语法、基本常用配置（主从配置，开启慢查询）、进行优化（引擎选择，建表，索引创建，如何构建高性能查询语句）.
5、熟练使用memcache和redis缓存
6、smarty模板引擎，html+css+js以及jquery的熟练使用
7、能够熟练使用git进行团队协作开发.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;工作经历&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;2014/11------至今    北京锥芒科技有限公司
担任职务	php高级工程师	
工作描述  与小组成员共同讨论网站的需求分析，负责项目功能模块的开发，参与相关技术点的攻关，配合测试部门协调进行测试，以及项目后期优化。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;项目经验&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;左岸女人
项目简介:
该项目是一个B2C型的美容化妆产品销售网站，网站中有商品筛选模块，用户可以根据自己的皮肤问题、护理的侧重面选择自己合适的护肤化妆品或美容工具等。网站中还有护肤学院模块，用户可以在其中学习到各种美容护肤方面的知识，帮助用户解决皮肤问题!
责任描述:
1、登录注册模块，对提交数据进行过滤防sql注入和xss攻击，引入第三方登录
2、网站首页的展示，包括分类信息，畅销商品、畅销工具的信息、文章信息，使用memcache进行缓存
3、护肤学院模块即文章模块开发
4、开发app端接口，整理接口文档
5、商品品牌信息的归类展示，根据品牌首字母进行归类展示（点击品牌里面有品牌的详细介绍，品牌相关商品展示，购买过此品牌商品用户对商品的评论展示）
6、负责前台用户中心模块（个人信息、我的资料、我的收藏、浏览记录）（第三方登录之后随机生成账号（账号无密码），所有账号必须绑定邮箱或手机号之后才能更改密码，用户详细信息如生日等可在后台详细编辑）

礼仪久久
项目简介:
礼仪久久是一个预订礼物送给别人的礼品订购网站，各种场合，各种节日，各种送礼对象，各种价格区间的礼品在这里你都可以找到，按照你的要求，给您提供最精美最合适的礼品并送到您的手中。
责任描述：
1.网站登录注册模块.(短信登录，第三方登录)
2.商品详情页展示（包括商品评价和用户咨询的展示）
3.使用sphinx进行商品搜索
4.购物车,完成对购物车商品的逻辑处理，入库并可以展示
5.完成生成订单页面的展示，包括地址填写，送达日期，贺卡及留言填写，支付方式选择。并完成订单的生成.

爱去小说网
项目简介: 该项目是一个小说在线阅读网站。网站大量采用静态化以及memcache缓存技术提高页面加载速度.
责任描述:
1.网站首页展示，包括最近更新，最新上架（使用缓存加快首页加载速度）.
2.小说按分类进行展示模块.
3.小说排行榜，周榜以及月榜的展示.
4.我的书架模块，加入书架的小说的展示.
5.最近阅读，把最近阅读的小说的章节数记录下来，方便下次接着阅读.
&lt;/code&gt;&lt;/pre&gt;
</content>
 </entry>
 
 <entry>
   <title>禁用cookie后session是如何设置的</title>
   <link href="https://zhuiyi1997.github.io//2016/10/17/session.html"/>
   <updated>2016-10-17T00:00:00+08:00</updated>
   <id>urn:uuid:b87da13a-a4dd-402f-b06a-cef7eeee2d80</id>
   <content type="html">&lt;p&gt;我们都知道当在session 会话有基于cookie和基于url两种传递SESSIONID的方法。为了实现客户端禁止cookie发送的情况也不影响客户登陆网站，可以设置 php.ini中 session.use_trans_sid=1 ，表示当客户端浏览器禁止cookie的时候，页面上的链接会基于url传递SESSIONID。但是很多人仅仅设置了这一个选项并没有达到效果，本人也 遇到此问题，后来一番研究发现
php.ini 文件中还有两个选项&lt;/p&gt;

&lt;p&gt;session.use_cookies=1&lt;/p&gt;

&lt;p&gt;session.use_only_cookies=1&lt;/p&gt;

&lt;p&gt;仔细琢磨上面的英文就会发现其意义&lt;/p&gt;

&lt;p&gt;session.use_cookies表示是否开始基于cookies的session会话&lt;/p&gt;

&lt;p&gt;session.use_only_cookies 表示是否只开启基于cookies的session的会话方式&lt;/p&gt;

&lt;p&gt;所以如果想要在浏览器开启cookie的时候用基于cookie的方式，在未开启cookie的时候使用url的方式就进行如下设置（最常用的方式，推荐）
在php.ini文件中&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;session.use_trans_sid=1
session.use_only_cookies=0
session.use_cookies=1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或者 在php程序中&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ini_set(“session.use_trans_sid”,”1″);
ini_set(“session.use_only_cookies”,0);
ini_set(“session.use_cookies”,1);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果不管浏览器是否开启cookie，都使用url的方式就进行如下设置（这个例子主要想说明一下设置session.use_only_cookies 和 session.use_cookies的区别）
在php.ini文件中&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;session.use_trans_sid=1
session.use_only_cookies=0
session.use_cookies=0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或者 在php程序中&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ini_set(“session.use_trans_sid”,”1″);
ini_set(“session.use_only_cookies”,0);
ini_set(“session.use_cookies”,0);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;动手自己试一试 你就会明白session.use_only_cookies 和 session.use_cookies的区别。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>PSR1代码规范4</title>
   <link href="https://zhuiyi1997.github.io//2016/10/16/psr4.html"/>
   <updated>2016-10-16T00:00:00+08:00</updated>
   <id>urn:uuid:b87da13a-a4dd-402f-b06a-cef7eeee2d80</id>
   <content type="html">&lt;h2 id=&quot;section&quot;&gt;1. 概况&lt;/h2&gt;

&lt;p&gt;这个 PSR 描述的是通过文件路径&lt;a href=&quot;http://php.net/autoload&quot;&gt;自动载入&lt;/a&gt;类的指南；它作为对 &lt;a href=&quot;https://github.com/hfcorriez/fig-standards/tree/master/accepted/zh_CN/PSR-0.md&quot;&gt;PSR-0&lt;/a&gt; 的补充；根据这个
指导如何规范存放文件来自动载入；&lt;/p&gt;

&lt;h2 id=&quot;specification&quot;&gt;2. 说明（Specification）&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;术语「类」是一个泛称；它包含类，接口，traits 以及其他类似的结构；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;完全限定类名应该类似如下范例：&lt;/p&gt;

    &lt;p&gt;&amp;lt;NamespaceName&amp;gt;(&amp;lt;SubNamespaceNames&amp;gt;)*&amp;lt;ClassName&amp;gt;&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;完全限定类名必须有一个顶级命名空间（Vendor Name）；&lt;/li&gt;
      &lt;li&gt;完全限定类名可以有多个子命名空间；&lt;/li&gt;
      &lt;li&gt;完全限定类名应该有一个终止类名；&lt;/li&gt;
      &lt;li&gt;下划线在完全限定类名中是没有特殊含义的；&lt;/li&gt;
      &lt;li&gt;字母在完全限定类名中可以是任何大小写的组合；&lt;/li&gt;
      &lt;li&gt;所有类名必须以大小写敏感的方式引用；&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;当从完全限定类名载入文件时：&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;在完全限定类名中，连续的一个或几个子命名空间构成的命名空间前缀（不包括顶级命名空间的分隔符），至少对应着至少一个基础目录。&lt;/li&gt;
      &lt;li&gt;在「命名空间前缀」后的连续子命名空间名称对应一个「基础目录」下的子目录，其中的命名
空间分隔符表示目录分隔符。子目录名称必须和子命名空间名大小写匹配；&lt;/li&gt;
      &lt;li&gt;终止类名对应一个以 &lt;code&gt;.php&lt;/code&gt; 结尾的文件。文件名必须和终止类名大小写匹配；&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;自动载入器的实现不可抛出任何异常，不可引发任何等级的错误；也不应返回值；&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;section-1&quot;&gt;3. 范例&lt;/h2&gt;

&lt;p&gt;如下表格展示的是与完全限定类名、命名空间前缀和基础目录相对应的文件路径：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;完全限定类名&lt;/th&gt;
      &lt;th&gt;命名空间前缀&lt;/th&gt;
      &lt;th&gt;基础目录&lt;/th&gt;
      &lt;th&gt;实际的文件路径&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;\Acme\Log\Writer\File_Writer&lt;/td&gt;
      &lt;td&gt;Acme\Log\Writer&lt;/td&gt;
      &lt;td&gt;./acme-log-writer/lib/&lt;/td&gt;
      &lt;td&gt;./acme-log-writer/lib/File_Writer.php&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;\Aura\Web\Response\Status&lt;/td&gt;
      &lt;td&gt;Aura\Web&lt;/td&gt;
      &lt;td&gt;/path/to/aura-web/src/&lt;/td&gt;
      &lt;td&gt;/path/to/aura-web/src/Response/Status.php&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;\Symfony\Core\Request&lt;/td&gt;
      &lt;td&gt;Symfony\Core&lt;/td&gt;
      &lt;td&gt;./vendor/Symfony/Core/&lt;/td&gt;
      &lt;td&gt;./vendor/Symfony/Core/Request.php&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;\Zend\Acl&lt;/td&gt;
      &lt;td&gt;Zend&lt;/td&gt;
      &lt;td&gt;/usr/includes/Zend/&lt;/td&gt;
      &lt;td&gt;/usr/includes/Zend/Acl.php&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;例子中的自动载入器非常适应这个指南，请参照 &lt;a href=&quot;http://www.php-fig.org/psr/psr-4/PSR-4-autoloader-examples.md&quot;&gt;示例文件&lt;/a&gt;。由于可能随时变更，实例不能作为指南的一部分。&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>PSR1代码规范3</title>
   <link href="https://zhuiyi1997.github.io//2016/10/16/psr3.html"/>
   <updated>2016-10-16T00:00:00+08:00</updated>
   <id>urn:uuid:b87da13a-a4dd-402f-b06a-cef7eeee2d80</id>
   <content type="html">&lt;h1 id=&quot;section&quot;&gt;日志接口&lt;/h1&gt;

&lt;p&gt;本文档描述了日志类库的通用接口。&lt;/p&gt;

&lt;p&gt;主要目标是让类库获得一个&lt;code&gt;Psr\Log\LoggerInterface&lt;/code&gt;对象并能通过简单通用的方式来写日志。有自定义需求的框架和CMS&lt;code&gt;可以&lt;/code&gt;根据情况扩展这个接口，但&lt;code&gt;推荐&lt;/code&gt;保持和该文档的兼容性，以确保应用中使用到的第三方库能将日志集中写到应用日志里。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://tools.ietf.org/html/rfc2119&quot;&gt;RFC 2119&lt;/a&gt;中的&lt;code&gt;必须(MUST)&lt;/code&gt;，&lt;code&gt;不可(MUST NOT)&lt;/code&gt;，&lt;code&gt;建议(SHOULD)&lt;/code&gt;，&lt;code&gt;不建议(SHOULD NOT)&lt;/code&gt;，&lt;code&gt;可以/可能(MAY)&lt;/code&gt;等关键词将在本节用来做一些解释性的描述。&lt;/p&gt;

&lt;p&gt;关键词&lt;code&gt;实现者&lt;/code&gt;在这个文档被解释为：在日志相关的库或框架实现&lt;code&gt;LoggerInterface&lt;/code&gt;接口的开发人员。用这些实现者开发出来的类库的人都被称作&lt;code&gt;用户&lt;/code&gt;。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;section-1&quot;&gt;规范&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;section-2&quot;&gt;1.1 基础&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code&gt;LoggerInterface&lt;/code&gt;暴露八个接口用来记录八个等级(debug, info, notice, warning, error, critical, alert, emergency)的日志。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;第九个方法是&lt;code&gt;log&lt;/code&gt;，接受日志等级作为第一个参数。用一个日志等级常量来调用这个方法&lt;code&gt;必须&lt;/code&gt;和直接调用指定等级方法的结果一致。用一个本规范中未定义且不为具体实现所知的日志等级来调用该方法&lt;code&gt;必须&lt;/code&gt;抛出一个&lt;code&gt;Psr\Log\InvalidArgumentException&lt;/code&gt;。&lt;code&gt;不推荐&lt;/code&gt;使用自定义的日志等级，除非你非常确定当前类库对其有所支持。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-3&quot;&gt;1.2 消息&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;每个方法都接受一个字符串，或者一个有&lt;code&gt;__toString&lt;/code&gt;方法的对象作为&lt;code&gt;message&lt;/code&gt;参数。&lt;code&gt;实现者&lt;/code&gt; &lt;code&gt;可以&lt;/code&gt;对传入的对象有特殊的处理。如果没有，&lt;code&gt;实现者&lt;/code&gt; &lt;code&gt;必须&lt;/code&gt;将它转换成字符串。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code&gt;message&lt;/code&gt;参数中&lt;code&gt;可能&lt;/code&gt;包含一些&lt;code&gt;可以&lt;/code&gt;被&lt;code&gt;context&lt;/code&gt;参数的数值所替换的占位符。&lt;/p&gt;

    &lt;p&gt;占位符名字&lt;code&gt;必须&lt;/code&gt;和&lt;code&gt;context&lt;/code&gt;数组类型参数的键名对应。&lt;/p&gt;

    &lt;p&gt;占位符名字&lt;code&gt;必须&lt;/code&gt;使用一对花括号来作为分隔符。在占位符和分隔符之间&lt;code&gt;不能&lt;/code&gt;有任何空格。&lt;/p&gt;

    &lt;p&gt;占位符名字&lt;code&gt;应该&lt;/code&gt;只能由&lt;code&gt;A-Z&lt;/code&gt;，&lt;code&gt;a-z&lt;/code&gt;，&lt;code&gt;0-9&lt;/code&gt;，下划线&lt;code&gt;_&lt;/code&gt;和句号&lt;code&gt;.&lt;/code&gt;组成。其它的字符作为以后占位符规范的保留字。&lt;/p&gt;

    &lt;p&gt;&lt;code&gt;实现者&lt;/code&gt; &lt;code&gt;可以&lt;/code&gt;使用占位符来实现不同的转义和翻译日志成文。因为&lt;code&gt;用户&lt;/code&gt;并不知道上下文数据会是什么，所以&lt;code&gt;不推荐&lt;/code&gt;提前转义占位符。&lt;/p&gt;

    &lt;p&gt;下面提供一个占位符替换的例子，仅作为参考：&lt;/p&gt;

    &lt;p&gt;```php
  &amp;lt;?php
  /**
   * Interpolates context values into the message placeholders.
   */
  function interpolate($message, array $context = array())
  {
      // build a replacement array with braces around the context keys
      $replace = array();
      foreach ($context as $key =&amp;gt; $val) {
          $replace[’{‘ . $key . ‘}’] = $val;
      }&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;  // interpolate replacement values into the message and return
  return strtr($message, $replace);   }
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;// a message with brace-delimited placeholder names
  $message = “User {username} created”;&lt;/p&gt;

    &lt;p&gt;// a context array of placeholder names =&amp;gt; replacement values
  $context = array(‘username’ =&amp;gt; ‘bolivar’);&lt;/p&gt;

    &lt;p&gt;// echoes “Username bolivar created”
  echo interpolate($message, $context);
  ```&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-4&quot;&gt;1.3 上下文&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;每个方法接受一个数组作为&lt;code&gt;context&lt;/code&gt;参数，用来存储不适合在字符串中填充的信息。数组可以包括任何东西。&lt;code&gt;实现者&lt;/code&gt; &lt;code&gt;必须&lt;/code&gt;确保他们尽可能包容的对&lt;code&gt;context&lt;/code&gt;参数进行处理。一个&lt;code&gt;context&lt;/code&gt;参数的给定值&lt;code&gt;不可&lt;/code&gt;导致抛出异常，也&lt;code&gt;不可&lt;/code&gt;产生任何PHP错误，警告或者提醒。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果在&lt;code&gt;context&lt;/code&gt;参数中传入了一个&lt;code&gt;异常&lt;/code&gt;对象，它必须以&lt;code&gt;exception&lt;/code&gt;作为键名。记录异常轨迹是通用的模式，并且可以在日志系统支持的情况下从异常中提取出整个调用栈。&lt;code&gt;实现者&lt;/code&gt;在将&lt;code&gt;exception&lt;/code&gt;当做&lt;code&gt;异常&lt;/code&gt;对象来使用之前&lt;code&gt;必须&lt;/code&gt;去验证它是不是一个&lt;code&gt;异常&lt;/code&gt;对象，因为它&lt;code&gt;可能&lt;/code&gt;包含着任何东西。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-5&quot;&gt;1.4 助手类和接口&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code&gt;Psr\Log\AbstractLogger&lt;/code&gt;类可以让你通过继承它并实现通用的&lt;code&gt;log&lt;/code&gt;方法来方便的实现&lt;code&gt;LoggerInterface&lt;/code&gt;接口。而其他八个方法将会把消息和上下文转发给&lt;code&gt;log&lt;/code&gt;方法。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;类似的，使用&lt;code&gt;Psr\Log\LoggerTrait&lt;/code&gt;只需要你实现通用的&lt;code&gt;log&lt;/code&gt;方法。注意特性是不能用来实现接口的，所以你依然需要在你的类中&lt;code&gt;implement LoggerInterface&lt;/code&gt;。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code&gt;Psr\Log\NullLogger&lt;/code&gt;是和接口一起提供的。它在没有可用的日志记录器时，&lt;code&gt;可以&lt;/code&gt;为使用日志接口的&lt;code&gt;用户&lt;/code&gt;们提供一个后备的“黑洞”。但是，当&lt;code&gt;context&lt;/code&gt;参数的构建非常耗时的时候，直接判断是否需要记录日志可能是个更好的选择。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code&gt;Psr\Log\LoggerAwareInterface&lt;/code&gt;只有一个&lt;code&gt;setLogger(LoggerInterface $logger)&lt;/code&gt;方法，它可以在框架中用来随意设置一个日志记录器。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code&gt;Psr\Log\LoggerAwareTrait&lt;/code&gt;特性可以被用来在各个类中轻松实现相同的接口。通过它可以访问到&lt;code&gt;$this-&amp;gt;logger&lt;/code&gt;。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code&gt;Psr\Log\LogLevel&lt;/code&gt;类拥有八个日志等级的常量。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;section-6&quot;&gt;包&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;a href=&quot;https://packagist.org/packages/psr/log&quot;&gt;psr/log&lt;/a&gt;中提供了上文描述过的接口和类，以及相关的异常类，还有一组用来验证你的实现的单元测试。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;psrlogloggerinterface&quot;&gt;&lt;code&gt;Psr\Log\LoggerInterface&lt;/code&gt;&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;```php
&amp;lt;?php&lt;/p&gt;

&lt;p&gt;namespace Psr\Log;&lt;/p&gt;

&lt;p&gt;/**
 * Describes a logger instance
 *
 * The message MUST be a string or object implementing __toString().
 *
 * The message MAY contain placeholders in the form: {foo} where foo
 * will be replaced by the context data in key “foo”.
 *
 * The context array can contain arbitrary data, the only assumption that
 * can be made by implementors is that if an Exception instance is given
 * to produce a stack trace, it MUST be in a key named “exception”.
 *
 * See https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-3-logger-interface.md
 * for the full interface specification.
 */
interface LoggerInterface
{
    /**
     * System is unusable.
     *
     * @param string $message
     * @param array $context
     * @return null
     */
    public function emergency($message, array $context = array());&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
 * Action must be taken immediately.
 *
 * Example: Entire website down, database unavailable, etc. This should
 * trigger the SMS alerts and wake you up.
 *
 * @param string $message
 * @param array $context
 * @return null
 */
public function alert($message, array $context = array());

/**
 * Critical conditions.
 *
 * Example: Application component unavailable, unexpected exception.
 *
 * @param string $message
 * @param array $context
 * @return null
 */
public function critical($message, array $context = array());

/**
 * Runtime errors that do not require immediate action but should typically
 * be logged and monitored.
 *
 * @param string $message
 * @param array $context
 * @return null
 */
public function error($message, array $context = array());

/**
 * Exceptional occurrences that are not errors.
 *
 * Example: Use of deprecated APIs, poor use of an API, undesirable things
 * that are not necessarily wrong.
 *
 * @param string $message
 * @param array $context
 * @return null
 */
public function warning($message, array $context = array());

/**
 * Normal but significant events.
 *
 * @param string $message
 * @param array $context
 * @return null
 */
public function notice($message, array $context = array());

/**
 * Interesting events.
 *
 * Example: User logs in, SQL logs.
 *
 * @param string $message
 * @param array $context
 * @return null
 */
public function info($message, array $context = array());

/**
 * Detailed debug information.
 *
 * @param string $message
 * @param array $context
 * @return null
 */
public function debug($message, array $context = array());

/**
 * Logs with an arbitrary level.
 *
 * @param mixed $level
 * @param string $message
 * @param array $context
 * @return null
 */
public function log($level, $message, array $context = array()); } ```
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;psrlogloggerawareinterface&quot;&gt;&lt;code&gt;Psr\Log\LoggerAwareInterface&lt;/code&gt;&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;```php
&amp;lt;?php&lt;/p&gt;

&lt;p&gt;namespace Psr\Log;&lt;/p&gt;

&lt;p&gt;/**
 * Describes a logger-aware instance
 */
interface LoggerAwareInterface
{
    /**
     * Sets a logger instance on the object
     *
     * @param LoggerInterface $logger
     * @return null
     */
    public function setLogger(LoggerInterface $logger);
}
```&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;psrlogloglevel&quot;&gt;&lt;code&gt;Psr\Log\LogLevel&lt;/code&gt;&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;```php
&amp;lt;?php&lt;/p&gt;

&lt;p&gt;namespace Psr\Log;&lt;/p&gt;

&lt;p&gt;/**
 * Describes log levels
 */
class LogLevel
{
    const EMERGENCY = ‘emergency’;
    const ALERT     = ‘alert’;
    const CRITICAL  = ‘critical’;
    const ERROR     = ‘error’;
    const WARNING   = ‘warning’;
    const NOTICE    = ‘notice’;
    const INFO      = ‘info’;
    const DEBUG     = ‘debug’;
}
```&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>PSR1代码规范2</title>
   <link href="https://zhuiyi1997.github.io//2016/10/16/psr2.html"/>
   <updated>2016-10-16T00:00:00+08:00</updated>
   <id>urn:uuid:b87da13a-a4dd-402f-b06a-cef7eeee2d80</id>
   <content type="html">&lt;h1 id=&quot;section&quot;&gt;代码风格指南&lt;/h1&gt;

&lt;p&gt;本手册是基础代码规范(&lt;a href=&quot;https://github.com/hfcorriez/fig-standards/blob/zh_CN/接受/PSR-1-basic-coding-standard.md&quot;&gt;PSR-1&lt;/a&gt;)的继承和扩展。&lt;/p&gt;

&lt;p&gt;为了尽可能的提升阅读其他人代码时的效率，下面例举了一系列的通用规则，特别是有关于PHP代码风格的。&lt;/p&gt;

&lt;p&gt;各个成员项目间的共性组成了这组代码规范。当开发者们在多个项目中合作时，本指南将会成为所有这些项目中共用的一组代码规范。 因此，本指南的益处不在于这些规则本身，而在于在所有项目中共用这些规则。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc2119.txt&quot;&gt;RFC 2119&lt;/a&gt;中的&lt;code&gt;必须(MUST)&lt;/code&gt;，&lt;code&gt;不可(MUST NOT)&lt;/code&gt;，&lt;code&gt;建议(SHOULD)&lt;/code&gt;，&lt;code&gt;不建议(SHOULD NOT)&lt;/code&gt;，&lt;code&gt;可以/可能(MAY)&lt;/code&gt;等关键词将在本节用来做一些解释性的描述。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;section-1&quot;&gt;概述&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;代码&lt;code&gt;必须&lt;/code&gt;遵守 &lt;a href=&quot;https://github.com/hfcorriez/fig-standards/blob/zh_CN/接受/PSR-1-basic-coding-standard.md&quot;&gt;PSR-1&lt;/a&gt;。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;代码&lt;code&gt;必须&lt;/code&gt;使用4个空格来进行缩进，而不是用制表符。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;一行代码的长度&lt;code&gt;不建议&lt;/code&gt;有硬限制；软限制&lt;code&gt;必须&lt;/code&gt;为120个字符，&lt;code&gt;建议&lt;/code&gt;每行代码80个字符或者更少。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在&lt;code&gt;命名空间(namespace)&lt;/code&gt;的声明下面&lt;code&gt;必须&lt;/code&gt;有一行空行，并且在&lt;code&gt;导入(use)&lt;/code&gt;的声明下面也&lt;code&gt;必须&lt;/code&gt;有一行空行。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code&gt;类(class)&lt;/code&gt;的左花括号&lt;code&gt;必须&lt;/code&gt;放到其声明下面自成一行，右花括号则&lt;code&gt;必须&lt;/code&gt;放到类主体下面自成一行。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code&gt;方法(method)&lt;/code&gt;的左花括号&lt;code&gt;必须&lt;/code&gt;放到其声明下面自成一行，右花括号则&lt;code&gt;必须&lt;/code&gt;放到方法主体的下一行。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;所有的&lt;code&gt;属性(property)&lt;/code&gt;和&lt;code&gt;方法(method)&lt;/code&gt; &lt;code&gt;必须&lt;/code&gt;有可见性声明；&lt;code&gt;抽象(abstract)&lt;/code&gt;和&lt;code&gt;终结(final)&lt;/code&gt;声明&lt;code&gt;必须&lt;/code&gt;在可见性声明之前；而&lt;code&gt;静态(static)&lt;/code&gt;声明&lt;code&gt;必须&lt;/code&gt;在可见性声明之后。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在控制结构关键字的后面&lt;code&gt;必须&lt;/code&gt;有一个空格；而&lt;code&gt;方法(method)&lt;/code&gt;和&lt;code&gt;函数(function)&lt;/code&gt;的关键字的后面&lt;code&gt;不可&lt;/code&gt;有空格。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;控制结构的左花括号&lt;code&gt;必须&lt;/code&gt;跟其放在同一行，右花括号&lt;code&gt;必须&lt;/code&gt;放在该控制结构代码主体的下一行。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;控制结构的左括号之后&lt;code&gt;不可&lt;/code&gt;有空格，右括号之前也&lt;code&gt;不可&lt;/code&gt;有空格。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-2&quot;&gt;1.1. 示例&lt;/h3&gt;

&lt;p&gt;这个示例中简单展示了上文中提到的一些规则：&lt;/p&gt;

&lt;p&gt;```php
&amp;lt;?php
namespace Vendor\Package;&lt;/p&gt;

&lt;p&gt;use FooInterface;
use BarClass as Bar;
use OtherVendor\OtherPackage\BazClass;&lt;/p&gt;

&lt;p&gt;class Foo extends Bar implements FooInterface
{
    public function sampleFunction($a, $b = null)
    {
        if ($a === $b) {
            bar();
        } elseif ($a &amp;gt; $b) {
            $foo-&amp;gt;bar($arg1);
        } else {
            BazClass::bar($arg2, $arg3);
        }
    }&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;final public static function bar()
{
    // 方法主体
} } ```
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;section-3&quot;&gt;通则&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;section-4&quot;&gt;2.1 基础代码规范&lt;/h3&gt;

&lt;p&gt;代码&lt;code&gt;必须&lt;/code&gt;遵守 &lt;a href=&quot;https://github.com/hfcorriez/fig-standards/blob/zh_CN/接受/PSR-1-basic-coding-standard.md&quot;&gt;PSR-1&lt;/a&gt; 中的所有规则。&lt;/p&gt;

&lt;h3 id=&quot;section-5&quot;&gt;2.2 源文件&lt;/h3&gt;

&lt;p&gt;所有的PHP源文件&lt;code&gt;必须&lt;/code&gt;使用Unix LF(换行)作为行结束符。&lt;/p&gt;

&lt;p&gt;所有PHP源文件&lt;code&gt;必须&lt;/code&gt;以一个空行结束。&lt;/p&gt;

&lt;p&gt;纯PHP代码源文件的关闭标签&lt;code&gt;?&amp;gt;&lt;/code&gt; &lt;code&gt;必须&lt;/code&gt;省略。&lt;/p&gt;

&lt;h3 id=&quot;section-6&quot;&gt;2.3. 行&lt;/h3&gt;

&lt;p&gt;行长度&lt;code&gt;不可&lt;/code&gt;有硬限制。&lt;/p&gt;

&lt;p&gt;行长度的软限制&lt;code&gt;必须&lt;/code&gt;是120个字符；对于软限制，代码风格检查器&lt;code&gt;必须&lt;/code&gt;警告但&lt;code&gt;不可&lt;/code&gt;报错。&lt;/p&gt;

&lt;p&gt;一行代码的长度&lt;code&gt;不建议&lt;/code&gt;超过80个字符；较长的行&lt;code&gt;建议&lt;/code&gt;拆分成多个不超过80个字符的子行。&lt;/p&gt;

&lt;p&gt;在非空行后面&lt;code&gt;不可&lt;/code&gt;有空格。&lt;/p&gt;

&lt;p&gt;空行&lt;code&gt;可以&lt;/code&gt;用来增强可读性和区分相关代码块。&lt;/p&gt;

&lt;p&gt;一行&lt;code&gt;不可&lt;/code&gt;多于一个语句。&lt;/p&gt;

&lt;h3 id=&quot;section-7&quot;&gt;2.4. 缩进&lt;/h3&gt;

&lt;p&gt;代码&lt;code&gt;必须&lt;/code&gt;使用4个空格，且&lt;code&gt;不可&lt;/code&gt;使用制表符来作为缩进。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;注意：代码中只使用空格，且不和制表符混合使用，将会对避免代码差异，补丁，历史和注解中的一些问题有帮助。空格的使用还可以使通过调整细微的缩进来改进行间对齐变得更加的简单。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;truefalsenull&quot;&gt;2.5. 关键字和 True/False/Null&lt;/h3&gt;

&lt;p&gt;PHP关键字(&lt;a href=&quot;http://php.net/manual/en/reserved.keywords.php&quot;&gt;keywords&lt;/a&gt;)&lt;code&gt;必须&lt;/code&gt;使用小写字母。&lt;/p&gt;

&lt;p&gt;PHP常量&lt;code&gt;true&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt;和&lt;code&gt;null&lt;/code&gt; &lt;code&gt;必须&lt;/code&gt;使用小写字母。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;namespaceuse&quot;&gt;&lt;code&gt;命名空间(Namespace)&lt;/code&gt;和&lt;code&gt;导入(Use)&lt;/code&gt;声明&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;code&gt;命名空间(namespace)&lt;/code&gt;的声明后面&lt;code&gt;必须&lt;/code&gt;有一行空行。&lt;/p&gt;

&lt;p&gt;所有的&lt;code&gt;导入(use)&lt;/code&gt;声明&lt;code&gt;必须&lt;/code&gt;放在&lt;code&gt;命名空间(namespace)&lt;/code&gt;声明的下面。&lt;/p&gt;

&lt;p&gt;一句声明中，&lt;code&gt;必须&lt;/code&gt;只有一个&lt;code&gt;导入(use)&lt;/code&gt;关键字。&lt;/p&gt;

&lt;p&gt;在&lt;code&gt;导入(use)&lt;/code&gt;声明代码块后面&lt;code&gt;必须&lt;/code&gt;有一行空行。&lt;/p&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;p&gt;```php
&amp;lt;?php
namespace Vendor\Package;&lt;/p&gt;

&lt;p&gt;use FooClass;
use BarClass as Bar;
use OtherVendor\OtherPackage\BazClass;&lt;/p&gt;

&lt;p&gt;// … 其它PHP代码 …&lt;/p&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;classpropertymethod&quot;&gt;&lt;code&gt;类(class)&lt;/code&gt;，&lt;code&gt;属性(property)&lt;/code&gt;和&lt;code&gt;方法(method)&lt;/code&gt;&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;术语“类”指所有的&lt;code&gt;类(class)&lt;/code&gt;，&lt;code&gt;接口(interface)&lt;/code&gt;和&lt;code&gt;特性(trait)&lt;/code&gt;。&lt;/p&gt;

&lt;h3 id=&quot;extendimplement&quot;&gt;4.1. &lt;code&gt;扩展(extend)&lt;/code&gt;和&lt;code&gt;实现(implement)&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;一个类的&lt;code&gt;扩展(extend)&lt;/code&gt;和&lt;code&gt;实现(implement)&lt;/code&gt;关键词&lt;code&gt;必须&lt;/code&gt;和&lt;code&gt;类名(class name)&lt;/code&gt;在同一行。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;类(class)&lt;/code&gt;的左花括号&lt;code&gt;必须&lt;/code&gt;放在下面自成一行；右花括号必须放在&lt;code&gt;类(class)&lt;/code&gt;主体的后面自成一行。&lt;/p&gt;

&lt;p&gt;```php
&amp;lt;?php
namespace Vendor\Package;&lt;/p&gt;

&lt;p&gt;use FooClass;
use BarClass as Bar;
use OtherVendor\OtherPackage\BazClass;&lt;/p&gt;

&lt;p&gt;class ClassName extends ParentClass implements \ArrayAccess, \Countable
{
    // 常量、属性、方法
}
```&lt;/p&gt;

&lt;p&gt;&lt;code&gt;实现(implement)&lt;/code&gt;列表&lt;code&gt;可以&lt;/code&gt;被拆分为多个缩进了一次的子行。如果要拆成多个子行，列表的第一项&lt;code&gt;必须&lt;/code&gt;要放在下一行，并且每行&lt;code&gt;必须&lt;/code&gt;只有一个&lt;code&gt;接口(interface)&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;```php
&amp;lt;?php
namespace Vendor\Package;&lt;/p&gt;

&lt;p&gt;use FooClass;
use BarClass as Bar;
use OtherVendor\OtherPackage\BazClass;&lt;/p&gt;

&lt;p&gt;class ClassName extends ParentClass implements
    \ArrayAccess,
    \Countable,
    \Serializable
{
    // 常量、属性、方法
}
```&lt;/p&gt;

&lt;h3 id=&quot;property&quot;&gt;4.2. &lt;code&gt;属性(property)&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;所有的&lt;code&gt;属性(property)&lt;/code&gt;都&lt;code&gt;必须&lt;/code&gt;声明其可见性。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;变量(var)&lt;/code&gt;关键字&lt;code&gt;不可&lt;/code&gt;用来声明一个&lt;code&gt;属性(property)&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;一条语句&lt;code&gt;不可&lt;/code&gt;声明多个&lt;code&gt;属性(property)&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;属性名(property name)&lt;/code&gt; &lt;code&gt;不推荐&lt;/code&gt;用单个下划线作为前缀来表明其&lt;code&gt;保护(protected)&lt;/code&gt;或&lt;code&gt;私有(private)&lt;/code&gt;的可见性。&lt;/p&gt;

&lt;p&gt;一个&lt;code&gt;属性(property)&lt;/code&gt;声明看起来应该像下面这样。&lt;/p&gt;

&lt;p&gt;```php
&amp;lt;?php
namespace Vendor\Package;&lt;/p&gt;

&lt;p&gt;class ClassName
{
    public $foo = null;
}
```&lt;/p&gt;

&lt;h3 id=&quot;method&quot;&gt;4.3. &lt;code&gt;方法(method)&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;所有的&lt;code&gt;方法(method)&lt;/code&gt;都&lt;code&gt;必须&lt;/code&gt;声明其可见性。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;方法名(method name)&lt;/code&gt; &lt;code&gt;不推荐&lt;/code&gt;用单个下划线作为前缀来表明其&lt;code&gt;保护(protected)&lt;/code&gt;或&lt;code&gt;私有(private)&lt;/code&gt;的可见性。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;方法名(method name)&lt;/code&gt;在其声明后面&lt;code&gt;不可&lt;/code&gt;有空格跟随。其左花括号&lt;code&gt;必须&lt;/code&gt;放在下面自成一行，且右花括号&lt;code&gt;必须&lt;/code&gt;放在方法主体的下面自成一行。左括号后面&lt;code&gt;不可&lt;/code&gt;有空格，且右括号前面也&lt;code&gt;不可&lt;/code&gt;有空格。&lt;/p&gt;

&lt;p&gt;一个&lt;code&gt;方法(method)&lt;/code&gt;声明看来应该像下面这样。 注意括号，逗号，空格和花括号的位置：&lt;/p&gt;

&lt;p&gt;```php
&amp;lt;?php
namespace Vendor\Package;&lt;/p&gt;

&lt;p&gt;class ClassName
{
    public function fooBarBaz($arg1, &amp;amp;$arg2, $arg3 = [])
    {
        // 方法主体部分
    }
}
```&lt;/p&gt;

&lt;h3 id=&quot;method-1&quot;&gt;4.4. &lt;code&gt;方法(method)&lt;/code&gt;的参数&lt;/h3&gt;

&lt;p&gt;在参数列表中，逗号之前&lt;code&gt;不可&lt;/code&gt;有空格，而逗号之后则&lt;code&gt;必须&lt;/code&gt;要有一个空格。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;方法(method)&lt;/code&gt;中有默认值的参数必须放在参数列表的最后面。&lt;/p&gt;

&lt;p&gt;```php
&amp;lt;?php
namespace Vendor\Package;&lt;/p&gt;

&lt;p&gt;class ClassName
{
    public function foo($arg1, &amp;amp;$arg2, $arg3 = [])
    {
        // 方法主体部分
    }
}
```&lt;/p&gt;

&lt;p&gt;参数列表&lt;code&gt;可以&lt;/code&gt;被拆分为多个缩进了一次的子行。如果要拆分成多个子行，参数列表的第一项&lt;code&gt;必须&lt;/code&gt;放在下一行，并且每行&lt;code&gt;必须&lt;/code&gt;只有一个参数。&lt;/p&gt;

&lt;p&gt;当参数列表被拆分成多个子行，右括号和左花括号之间&lt;code&gt;必须&lt;/code&gt;又一个空格并且自成一行。&lt;/p&gt;

&lt;p&gt;```php
&amp;lt;?php
namespace Vendor\Package;&lt;/p&gt;

&lt;p&gt;class ClassName
{
    public function aVeryLongMethodName(
        ClassTypeHint $arg1,
        &amp;amp;$arg2,
        array $arg3 = []
    ) {
        // 方法主体部分
    }
}
```&lt;/p&gt;

&lt;h3 id=&quot;abstractfinal-static&quot;&gt;4.5. &lt;code&gt;抽象(abstract)&lt;/code&gt;，&lt;code&gt;终结(final)&lt;/code&gt;和 &lt;code&gt;静态(static)&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;当用到&lt;code&gt;抽象(abstract)&lt;/code&gt;和&lt;code&gt;终结(final)&lt;/code&gt;来做类声明时，它们&lt;code&gt;必须&lt;/code&gt;放在可见性声明的前面。&lt;/p&gt;

&lt;p&gt;而当用到&lt;code&gt;静态(static)&lt;/code&gt;来做类声明时，则&lt;code&gt;必须&lt;/code&gt;放在可见性声明的后面。&lt;/p&gt;

&lt;p&gt;```php
&amp;lt;?php
namespace Vendor\Package;&lt;/p&gt;

&lt;p&gt;abstract class ClassName
{
    protected static $foo;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;abstract protected function zim();

final public static function bar()
{
    // 方法主体部分
} } ```
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-8&quot;&gt;4.6. 调用方法和函数&lt;/h3&gt;

&lt;p&gt;调用一个方法或函数时，在方法名或者函数名和左括号之间&lt;code&gt;不可&lt;/code&gt;有空格，左括号之后&lt;code&gt;不可&lt;/code&gt;有空格，右括号之前也&lt;code&gt;不可&lt;/code&gt;有空格。参数列表中，逗号之前&lt;code&gt;不可&lt;/code&gt;有空格，逗号之后则&lt;code&gt;必须&lt;/code&gt;有一个空格。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;php
&amp;lt;?php
bar();
$foo-&amp;gt;bar($arg1);
Foo::bar($arg2, $arg3);
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;参数列表&lt;code&gt;可以&lt;/code&gt;被拆分成多个缩进了一次的子行。如果拆分成子行，列表中的第一项&lt;code&gt;必须&lt;/code&gt;放在下一行，并且每一行&lt;code&gt;必须&lt;/code&gt;只能有一个参数。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;php
&amp;lt;?php
$foo-&amp;gt;bar(
    $longArgument,
    $longerArgument,
    $muchLongerArgument
);
&lt;/code&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;section-9&quot;&gt;控制结构&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;下面是对于控制结构代码风格的概括：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;控制结构的关键词之后&lt;code&gt;必须&lt;/code&gt;有一个空格。&lt;/li&gt;
  &lt;li&gt;控制结构的左括号之后&lt;code&gt;不可&lt;/code&gt;有空格。&lt;/li&gt;
  &lt;li&gt;控制结构的右括号之前&lt;code&gt;不可&lt;/code&gt;有空格。&lt;/li&gt;
  &lt;li&gt;控制结构的右括号和左花括号之间&lt;code&gt;必须&lt;/code&gt;有一个空格。&lt;/li&gt;
  &lt;li&gt;控制结构的代码主体&lt;code&gt;必须&lt;/code&gt;进行一次缩进。&lt;/li&gt;
  &lt;li&gt;控制结构的右花括号&lt;code&gt;必须&lt;/code&gt;主体的下一行。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;每个控制结构的代码主体&lt;code&gt;必须&lt;/code&gt;被括在花括号里。这样可是使代码看上去更加标准化，并且加入新代码的时候还可以因此而减少引入错误的可能性。&lt;/p&gt;

&lt;h3 id=&quot;ifelseifelse&quot;&gt;5.1. &lt;code&gt;if&lt;/code&gt;，&lt;code&gt;elseif&lt;/code&gt;，&lt;code&gt;else&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;下面是一个&lt;code&gt;if&lt;/code&gt;条件控制结构的示例，注意其中括号，空格和花括号的位置。同时注意&lt;code&gt;else&lt;/code&gt;和&lt;code&gt;elseif&lt;/code&gt;要和前一个条件控制结构的右花括号在同一行。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;php
&amp;lt;?php
if ($expr1) {
    // if body
} elseif ($expr2) {
    // elseif body
} else {
    // else body;
}
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;推荐&lt;/code&gt;用&lt;code&gt;elseif&lt;/code&gt;来替代&lt;code&gt;else if&lt;/code&gt;，以保持所有的条件控制关键字看起来像是一个单词。&lt;/p&gt;

&lt;h3 id=&quot;switchcase&quot;&gt;5.2. &lt;code&gt;switch&lt;/code&gt;，&lt;code&gt;case&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;下面是一个&lt;code&gt;switch&lt;/code&gt;条件控制结构的示例，注意其中括号，空格和花括号的位置。&lt;code&gt;case&lt;/code&gt;语句&lt;code&gt;必须&lt;/code&gt;要缩进一级，而&lt;code&gt;break&lt;/code&gt;关键字（或其他中止关键字）&lt;code&gt;必须&lt;/code&gt;和&lt;code&gt;case&lt;/code&gt;结构的代码主体在同一个缩进层级。如果一个有主体代码的&lt;code&gt;case&lt;/code&gt;结构故意的继续向下执行则&lt;code&gt;必须&lt;/code&gt;要有一个类似于&lt;code&gt;// no break&lt;/code&gt;的注释。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;php
&amp;lt;?php
switch ($expr) {
    case 0:
        echo &#39;First case, with a break&#39;;
        break;
    case 1:
        echo &#39;Second case, which falls through&#39;;
        // no break
    case 2:
    case 3:
    case 4:
        echo &#39;Third case, return instead of break&#39;;
        return;
    default:
        echo &#39;Default case&#39;;
        break;
}
&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;whiledo-while&quot;&gt;5.3. &lt;code&gt;while&lt;/code&gt;，&lt;code&gt;do while&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;下面是一个&lt;code&gt;while&lt;/code&gt;循环控制结构的示例，注意其中括号，空格和花括号的位置。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;php
&amp;lt;?php
while ($expr) {
    // structure body
}
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;下面是一个&lt;code&gt;do while&lt;/code&gt;循环控制结构的示例，注意其中括号，空格和花括号的位置。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;php
&amp;lt;?php
do {
    // structure body;
} while ($expr);
&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;for&quot;&gt;5.4. &lt;code&gt;for&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;下面是一个&lt;code&gt;for&lt;/code&gt;循环控制结构的示例，注意其中括号，空格和花括号的位置。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;php
&amp;lt;?php
for ($i = 0; $i &amp;lt; 10; $i++) {
    // for body
}
&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;foreach&quot;&gt;5.5. &lt;code&gt;foreach&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;下面是一个&lt;code&gt;foreach&lt;/code&gt;循环控制结构的示例，注意其中括号，空格和花括号的位置。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;php
&amp;lt;?php
foreach ($iterable as $key =&amp;gt; $value) {
    // foreach body
}
&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;try-catch&quot;&gt;5.6. &lt;code&gt;try&lt;/code&gt;, &lt;code&gt;catch&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;下面是一个&lt;code&gt;try catch&lt;/code&gt;异常处理控制结构的示例，注意其中括号，空格和花括号的位置。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;php
&amp;lt;?php
try {
    // try body
} catch (FirstExceptionType $e) {
    // catch body
} catch (OtherExceptionType $e) {
    // catch body
}
&lt;/code&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;section-10&quot;&gt;闭包&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;声明闭包时所用的&lt;code&gt;function&lt;/code&gt;关键字之后&lt;code&gt;必须&lt;/code&gt;要有一个空格，而&lt;code&gt;use&lt;/code&gt;关键字的前后都要有一个空格。&lt;/p&gt;

&lt;p&gt;闭包的左花括号&lt;code&gt;必须&lt;/code&gt;跟其在同一行，而右花括号&lt;code&gt;必须&lt;/code&gt;在闭包主体的下一行。&lt;/p&gt;

&lt;p&gt;闭包的参数列表和变量列表的左括号后面&lt;code&gt;不可&lt;/code&gt;有空格，右括号的前面也&lt;code&gt;不可&lt;/code&gt;有空格。&lt;/p&gt;

&lt;p&gt;闭包的参数列表和变量列表中逗号前面&lt;code&gt;不可&lt;/code&gt;有空格，而逗号后面则&lt;code&gt;必须&lt;/code&gt;有空格。&lt;/p&gt;

&lt;p&gt;闭包的参数列表中带默认值的参数&lt;code&gt;必须&lt;/code&gt;放在参数列表的结尾部分。&lt;/p&gt;

&lt;p&gt;下面是一个闭包的示例。注意括号，空格和花括号的位置。&lt;/p&gt;

&lt;p&gt;```php
&amp;lt;?php
$closureWithArgs = function ($arg1, $arg2) {
    // body
};&lt;/p&gt;

&lt;p&gt;$closureWithArgsAndVars = function ($arg1, $arg2) use ($var1, $var2) {
    // body
};
```&lt;/p&gt;

&lt;p&gt;参数列表和变量列表&lt;code&gt;可以&lt;/code&gt;被拆分成多个缩进了一级的子行。如果要拆分成多个子行，列表中的第一项&lt;code&gt;必须&lt;/code&gt;放在下一行，并且每一行&lt;code&gt;必须&lt;/code&gt;只放一个参数或变量。&lt;/p&gt;

&lt;p&gt;当列表（不管是参数还是变量）最终被拆分成多个子行，右括号和左花括号之间&lt;code&gt;必须&lt;/code&gt;要有一个空格并且自成一行。&lt;/p&gt;

&lt;p&gt;下面是一个参数列表和变量列表被拆分成多个子行的示例。&lt;/p&gt;

&lt;p&gt;```php
&amp;lt;?php
$longArgs_noVars = function (
    $longArgument,
    $longerArgument,
    $muchLongerArgument
) {
   // body
};&lt;/p&gt;

&lt;p&gt;$noArgs_longVars = function () use (
    $longVar1,
    $longerVar2,
    $muchLongerVar3
) {
   // body
};&lt;/p&gt;

&lt;p&gt;$longArgs_longVars = function (
    $longArgument,
    $longerArgument,
    $muchLongerArgument
) use (
    $longVar1,
    $longerVar2,
    $muchLongerVar3
) {
   // body
};&lt;/p&gt;

&lt;p&gt;$longArgs_shortVars = function (
    $longArgument,
    $longerArgument,
    $muchLongerArgument
) use ($var1) {
   // body
};&lt;/p&gt;

&lt;p&gt;$shortArgs_longVars = function ($arg) use (
    $longVar1,
    $longerVar2,
    $muchLongerVar3
) {
   // body
};
```&lt;/p&gt;

&lt;p&gt;把闭包作为一个参数在函数或者方法中调用时，依然要遵守上述规则。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;php
&amp;lt;?php
$foo-&amp;gt;bar(
    $arg1,
    function ($arg2) use ($var1) {
        // body
    },
    $arg3
);
&lt;/code&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;section-11&quot;&gt;结论&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;本指南有意的省略了许多元素的代码风格。主要包括：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;全局变量和全局常量的声明&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;函数声明&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;操作符和赋值&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;行间对齐&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;注释和文档块&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;类名的前缀和后缀&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;最佳实践&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;以后的代码规范中&lt;code&gt;可能&lt;/code&gt;会修正或扩展本指南中规定的代码风格。&lt;/p&gt;

&lt;h2 id=&quot;a-&quot;&gt;附录A 调查&lt;/h2&gt;

&lt;p&gt;为了写这个风格指南，我们调查了各个项目以最终确定通用的代码风格。并把这次调查在这里公布出来。&lt;/p&gt;

&lt;h3 id=&quot;a1-&quot;&gt;A.1. 调查数据&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;url,http://www.horde.org/apps/horde/docs/CODING_STANDARDS,http://pear.php.net/manual/en/standards.php,http://solarphp.com/manual/appendix-standards.style,http://framework.zend.com/manual/en/coding-standard.html,http://symfony.com/doc/2.0/contributing/code/standards.html,http://www.ppi.io/docs/coding-standards.html,https://github.com/ezsystems/ezp-next/wiki/codingstandards,http://book.cakephp.org/2.0/en/contributing/cakephp-coding-conventions.html,https://github.com/UnionOfRAD/lithium/wiki/Spec%3A-Coding,http://drupal.org/coding-standards,http://code.google.com/p/sabredav/,http://area51.phpbb.com/docs/31x/coding-guidelines.html,https://docs.google.com/a/zikula.org/document/edit?authkey=CPCU0Us&amp;amp;hgd=1&amp;amp;id=1fcqb93Sn-hR9c0mkN6m_tyWnmEvoswKBtSc0tKkZmJA,http://www.chisimba.com,n/a,https://github.com/Respect/project-info/blob/master/coding-standards-sample.php,n/a,Object Calisthenics for PHP,http://doc.nette.org/en/coding-standard,http://flow3.typo3.org,https://github.com/propelorm/Propel2/wiki/Coding-Standards,http://developer.joomla.org/coding-standards.html
voting,yes,yes,yes,yes,yes,yes,yes,yes,yes,yes,yes,yes,yes,yes,yes,no,no,no,?,yes,no,yes
indent_type,4,4,4,4,4,tab,4,tab,tab,2,4,tab,4,4,4,4,4,4,tab,tab,4,tab
line_length_limit_soft,75,75,75,75,no,85,120,120,80,80,80,no,100,80,80,?,?,120,80,120,no,150
line_length_limit_hard,85,85,85,85,no,no,no,no,100,?,no,no,no,100,100,?,120,120,no,no,no,no
class_names,studly,studly,studly,studly,studly,studly,studly,studly,studly,studly,studly,lower_under,studly,lower,studly,studly,studly,studly,?,studly,studly,studly
class_brace_line,next,next,next,next,next,same,next,same,same,same,same,next,next,next,next,next,next,next,next,same,next,next
constant_names,upper,upper,upper,upper,upper,upper,upper,upper,upper,upper,upper,upper,upper,upper,upper,upper,upper,upper,upper,upper,upper,upper
true_false_null,lower,lower,lower,lower,lower,lower,lower,lower,lower,upper,lower,lower,lower,upper,lower,lower,lower,lower,lower,upper,lower,lower
method_names,camel,camel,camel,camel,camel,camel,camel,camel,camel,camel,camel,lower_under,camel,camel,camel,camel,camel,camel,camel,camel,camel,camel
method_brace_line,next,next,next,next,next,same,next,same,same,same,same,next,next,same,next,next,next,next,next,same,next,next
control_brace_line,same,same,same,same,same,same,next,same,same,same,same,next,same,same,next,same,same,same,same,same,same,next
control_space_after,yes,yes,yes,yes,yes,no,yes,yes,yes,yes,no,yes,yes,yes,yes,yes,yes,yes,yes,yes,yes,yes
always_use_control_braces,yes,yes,yes,yes,yes,yes,no,yes,yes,yes,no,yes,yes,yes,yes,no,yes,yes,yes,yes,yes,yes
else_elseif_line,same,same,same,same,same,same,next,same,same,next,same,next,same,next,next,same,same,same,same,same,same,next
case_break_indent_from_switch,0/1,0/1,0/1,1/2,1/2,1/2,1/2,1/1,1/1,1/2,1/2,1/1,1/2,1/2,1/2,1/2,1/2,1/2,0/1,1/1,1/2,1/2
function_space_after,no,no,no,no,no,no,no,no,no,no,no,no,no,no,no,no,no,no,no,no,no,no
closing_php_tag_required,no,no,no,no,no,no,no,no,yes,no,no,no,no,yes,no,no,no,no,no,yes,no,no
line_endings,LF,LF,LF,LF,LF,LF,LF,LF,?,LF,?,LF,LF,LF,LF,?,,LF,?,LF,LF,LF
static_or_visibility_first,static,?,static,either,either,either,visibility,visibility,visibility,either,static,either,?,visibility,?,?,either,either,visibility,visibility,static,?
control_space_parens,no,no,no,no,no,no,yes,no,no,no,no,no,no,yes,?,no,no,no,no,no,no,no
blank_line_after_php,no,no,no,no,yes,no,no,no,no,yes,yes,no,no,yes,?,yes,yes,no,yes,no,yes,no
class_method_control_brace,next/next/same,next/next/same,next/next/same,next/next/same,next/next/same,same/same/same,next/next/next,same/same/same,same/same/same,same/same/same,same/same/same,next/next/next,next/next/same,next/same/same,next/next/next,next/next/same,next/next/same,next/next/same,next/next/same,same/same/same,next/next/same,next/next/next
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;a2-&quot;&gt;A.2. 调查说明&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;indent_type&lt;/code&gt;:
缩进类型。 &lt;code&gt;tab&lt;/code&gt; = “使用制表符”，&lt;code&gt;2&lt;/code&gt; or &lt;code&gt;4&lt;/code&gt; = “空格数量”&lt;/p&gt;

&lt;p&gt;&lt;code&gt;line_length_limit_soft&lt;/code&gt;:
行长度的“软”限制，用字符。 &lt;code&gt;?&lt;/code&gt; = 不表示或者数字 &lt;code&gt;no&lt;/code&gt; 意为不限制.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;line_length_limit_hard&lt;/code&gt;:
行长度的”硬”限制，用字符。 &lt;code&gt;?&lt;/code&gt; = 不表示或者数字, &lt;code&gt;no&lt;/code&gt; 意为不限制.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;class_names&lt;/code&gt;:
类名如何命名 &lt;code&gt;lower&lt;/code&gt; = 只是小写, &lt;code&gt;lower_under&lt;/code&gt; = 小写加下划线, &lt;code&gt;studly&lt;/code&gt; = 骆驼型.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;class_brace_line&lt;/code&gt;:
类的左花括号是放在同(&lt;code&gt;same&lt;/code&gt;)一行还是在下(&lt;code&gt;next&lt;/code&gt;)一行？&lt;/p&gt;

&lt;p&gt;&lt;code&gt;constant_names&lt;/code&gt;:
类常量如何命名？&lt;code&gt;upper&lt;/code&gt; = 大写加下划线分隔符。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;true_false_null&lt;/code&gt;:
全小写或者全大写？&lt;/p&gt;

&lt;p&gt;&lt;code&gt;method_names&lt;/code&gt;:
方法名如何命名？&lt;code&gt;camel&lt;/code&gt; = &lt;code&gt;驼峰式&lt;/code&gt;, &lt;code&gt;lower_under&lt;/code&gt; = 小写加下划线分隔符。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;method_brace_line&lt;/code&gt;:
方法的左花括号在同(&lt;code&gt;same&lt;/code&gt;)一行还是在下(&lt;code&gt;next&lt;/code&gt;)一行？&lt;/p&gt;

&lt;p&gt;&lt;code&gt;control_brace_line&lt;/code&gt;:
控制结构的左花括号在同(&lt;code&gt;same&lt;/code&gt;)一行还是在下(&lt;code&gt;next&lt;/code&gt;)一行？&lt;/p&gt;

&lt;p&gt;&lt;code&gt;control_space_after&lt;/code&gt;:
控制结构关键词后是否有空格？&lt;/p&gt;

&lt;p&gt;&lt;code&gt;always_use_control_braces&lt;/code&gt;:
控制结构总是使用花括号？&lt;/p&gt;

&lt;p&gt;&lt;code&gt;else_elseif_line&lt;/code&gt;:
当使用&lt;code&gt;else&lt;/code&gt;和&lt;code&gt;elseif&lt;/code&gt;，是否放在同(&lt;code&gt;same&lt;/code&gt;)一行还是在下(&lt;code&gt;next&lt;/code&gt;)一行？&lt;/p&gt;

&lt;p&gt;&lt;code&gt;case_break_indent_from_switch&lt;/code&gt;:
&lt;code&gt;case&lt;/code&gt;和&lt;code&gt;break&lt;/code&gt;分别从&lt;code&gt;swith&lt;/code&gt;语句处缩进多少次？&lt;/p&gt;

&lt;p&gt;&lt;code&gt;function_space_after&lt;/code&gt;:
函数调用的函数名和左括号是否有空格？&lt;/p&gt;

&lt;p&gt;&lt;code&gt;closing_php_tag_required&lt;/code&gt;:
如过是纯PHP文件，关闭标签&lt;code&gt;?&amp;gt;&lt;/code&gt;是否需要？&lt;/p&gt;

&lt;p&gt;&lt;code&gt;line_endings&lt;/code&gt;:
使用何种的行结束符？&lt;/p&gt;

&lt;p&gt;&lt;code&gt;static_or_visibility_first&lt;/code&gt;:
在定义方法的时候&lt;code&gt;static&lt;/code&gt;和可见性谁在前面？&lt;/p&gt;

&lt;p&gt;&lt;code&gt;control_space_parens&lt;/code&gt;:
在控制结构表达式中，左括号后面和右括号前面是否要有一个空格？&lt;code&gt;yes&lt;/code&gt; = &lt;code&gt;if ( $expr )&lt;/code&gt;, &lt;code&gt;no&lt;/code&gt; = &lt;code&gt;if ($expr)&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;blank_line_after_php&lt;/code&gt;:
PHP的开始标签后面是否需要一个空行？&lt;/p&gt;

&lt;p&gt;&lt;code&gt;class_method_control_brace&lt;/code&gt;:
左花括号在类，方法和控制结构中的位置。&lt;/p&gt;

&lt;h3 id=&quot;a3-&quot;&gt;A.3. 调查结果&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;indent_type:
    tab: 7
    2: 1
    4: 14
line_length_limit_soft:
    ?: 2
    no: 3
    75: 4
    80: 6
    85: 1
    100: 1
    120: 4
    150: 1
line_length_limit_hard:
    ?: 2
    no: 11
    85: 4
    100: 3
    120: 2
class_names:
    ?: 1
    lower: 1
    lower_under: 1
    studly: 19
class_brace_line:
    next: 16
    same: 6
constant_names:
    upper: 22
true_false_null:
    lower: 19
    upper: 3
method_names:
    camel: 21
    lower_under: 1
method_brace_line:
    next: 15
    same: 7
control_brace_line:
    next: 4
    same: 18
control_space_after:
    no: 2
    yes: 20
always_use_control_braces:
    no: 3
    yes: 19
else_elseif_line:
    next: 6
    same: 16
case_break_indent_from_switch:
    0/1: 4
    1/1: 4
    1/2: 14
function_space_after:
    no: 22
closing_php_tag_required:
    no: 19
    yes: 3
line_endings:
    ?: 5
    LF: 17
static_or_visibility_first:
    ?: 5
    either: 7
    static: 4
    visibility: 6
control_space_parens:
    ?: 1
    no: 19
    yes: 2
blank_line_after_php:
    ?: 1
    no: 13
    yes: 8
class_method_control_brace:
    next/next/next: 4
    next/next/same: 11
    next/same/same: 1
    same/same/same: 6
&lt;/code&gt;&lt;/pre&gt;
</content>
 </entry>
 
 <entry>
   <title>PSR1代码规范1</title>
   <link href="https://zhuiyi1997.github.io//2016/10/16/psr1.html"/>
   <updated>2016-10-16T00:00:00+08:00</updated>
   <id>urn:uuid:b87da13a-a4dd-402f-b06a-cef7eeee2d80</id>
   <content type="html">&lt;h1 id=&quot;section&quot;&gt;基本代码规范&lt;/h1&gt;

&lt;p&gt;本节我们将会讨论一些基本的代码规范问题，以此作为将来讨论更高级别的代码分享和技术互用的基础。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc2119.txt&quot;&gt;RFC 2119&lt;/a&gt;中的&lt;code&gt;必须(MUST)&lt;/code&gt;，&lt;code&gt;不可(MUST NOT)&lt;/code&gt;，&lt;code&gt;建议(SHOULD)&lt;/code&gt;，&lt;code&gt;不建议(SHOULD NOT)&lt;/code&gt;，&lt;code&gt;可以/可能(MAY)&lt;/code&gt;等关键词将在本节用来做一些解释性的描述。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;section-1&quot;&gt;概述&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;源文件&lt;code&gt;必须&lt;/code&gt;只使用 &lt;code&gt;&amp;lt;?php&lt;/code&gt; 和 &lt;code&gt;&amp;lt;?=&lt;/code&gt; 这两种标签。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;源文件中php代码的编码格式&lt;code&gt;必须&lt;/code&gt;只使用不带&lt;code&gt;字节顺序标记(BOM)&lt;/code&gt;的&lt;code&gt;UTF-8&lt;/code&gt;。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;一个源文件&lt;code&gt;建议&lt;/code&gt;只用来做声明（&lt;code&gt;类(class)&lt;/code&gt;，&lt;code&gt;函数(function)&lt;/code&gt;，&lt;code&gt;常量(constant)&lt;/code&gt;等）或者只用来做一些引起副作用的操作（例如：输出信息，修改&lt;code&gt;.ini&lt;/code&gt;配置等）,但&lt;code&gt;不建议&lt;/code&gt;同时做这两件事。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code&gt;命名空间(namespace)&lt;/code&gt;和&lt;code&gt;类(class)&lt;/code&gt; &lt;code&gt;必须&lt;/code&gt;遵守&lt;a href=&quot;https://github.com/hfcorriez/fig-standards/blob/zh_CN/接受/PSR-0.md&quot;&gt;PSR-0&lt;/a&gt;标准。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code&gt;类名(class name)&lt;/code&gt; &lt;code&gt;必须&lt;/code&gt;使用&lt;code&gt;骆驼式(StudlyCaps)&lt;/code&gt;写法 (译者注：&lt;code&gt;驼峰式(cameCase)&lt;/code&gt;的一种变种，后文将直接用&lt;code&gt;StudlyCaps&lt;/code&gt;表示)。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code&gt;类(class)&lt;/code&gt;中的常量&lt;code&gt;必须&lt;/code&gt;只由大写字母和&lt;code&gt;下划线(_)&lt;/code&gt;组成。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code&gt;方法名(method name)&lt;/code&gt; &lt;code&gt;必须&lt;/code&gt;使用&lt;code&gt;驼峰式(cameCase)&lt;/code&gt;写法(译者注：后文将直接用&lt;code&gt;camelCase&lt;/code&gt;表示)。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;section-2&quot;&gt;文件&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;php&quot;&gt;2.1. PHP标签&lt;/h3&gt;

&lt;p&gt;PHP代码&lt;code&gt;必须&lt;/code&gt;只使用&lt;code&gt;长标签(&amp;lt;?php ?&amp;gt;)&lt;/code&gt;或者&lt;code&gt;短输出式标签(&amp;lt;?= ?&amp;gt;)&lt;/code&gt;；而&lt;code&gt;不可&lt;/code&gt;使用其他标签。&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;2.2. 字符编码&lt;/h3&gt;

&lt;p&gt;PHP代码的编码格式&lt;code&gt;必须&lt;/code&gt;只使用不带&lt;code&gt;字节顺序标记(BOM)&lt;/code&gt;的&lt;code&gt;UTF-8&lt;/code&gt;。&lt;/p&gt;

&lt;h3 id=&quot;section-4&quot;&gt;2.3. 副作用&lt;/h3&gt;

&lt;p&gt;一个源文件&lt;code&gt;建议&lt;/code&gt;只用来做声明（&lt;code&gt;类(class)&lt;/code&gt;，&lt;code&gt;函数(function)&lt;/code&gt;，&lt;code&gt;常量(constant)&lt;/code&gt;等）或者只用来做一些引起副作用的操作（例如：输出信息，修改&lt;code&gt;.ini&lt;/code&gt;配置等）,但&lt;code&gt;不建议&lt;/code&gt;同时做这两件事。&lt;/p&gt;

&lt;p&gt;短语&lt;code&gt;副作用(side effects)&lt;/code&gt;的意思是 &lt;em&gt;在包含文件时&lt;/em&gt; 所执行的逻辑与所声明的&lt;code&gt;类(class)&lt;/code&gt;，&lt;code&gt;函数(function)&lt;/code&gt;，&lt;code&gt;常量(constant)&lt;/code&gt;等没有直接的关系。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;副作用(side effects)&lt;/code&gt;包含但不局限于：产生输出，显式地使用&lt;code&gt;require&lt;/code&gt;或&lt;code&gt;include&lt;/code&gt;，连接外部服务，修改ini配置，触发错误或异常，修改全局或者静态变量，读取或修改文件等等&lt;/p&gt;

&lt;p&gt;下面是一个既包含声明又有副作用的示例文件；即应避免的例子：&lt;/p&gt;

&lt;p&gt;```php
&amp;lt;?php
// 副作用：修改了ini配置
ini_set(‘error_reporting’, E_ALL);&lt;/p&gt;

&lt;p&gt;// 副作用：载入了文件
include “file.php”;&lt;/p&gt;

&lt;p&gt;// 副作用：产生了输出
echo “&amp;lt;html&amp;gt;\n”;&lt;/p&gt;

&lt;p&gt;// 声明
function foo()
{
    // 函数体
}
```&lt;/p&gt;

&lt;p&gt;下面是一个仅包含声明的示例文件；即应提倡的例子：&lt;/p&gt;

&lt;p&gt;```php
&amp;lt;?php
// 声明
function foo()
{
    // 函数体
}&lt;/p&gt;

&lt;p&gt;// 条件式声明不算做是副作用
if (! function_exists(‘bar’)) {
    function bar()
    {
        // 函数体
    }
}
```&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;namespaceclass-name&quot;&gt;&lt;code&gt;空间名(namespace)&lt;/code&gt;和&lt;code&gt;类名(class name)&lt;/code&gt;&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;code&gt;命名空间(namespace)&lt;/code&gt;和&lt;code&gt;类(class)&lt;/code&gt;必须遵守 &lt;a href=&quot;https://github.com/hfcorriez/fig-standards/blob/zh_CN/接受/PSR-0.md&quot;&gt;PSR-0&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;这意味着一个源文件中只能有一个&lt;code&gt;类(class)&lt;/code&gt;，并且每个&lt;code&gt;类(class)&lt;/code&gt;至少要有一级&lt;code&gt;空间名（namespace）&lt;/code&gt;：即一个顶级的&lt;code&gt;组织名(vendor name)&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;类名(class name)&lt;/code&gt; &lt;code&gt;必须&lt;/code&gt;使用&lt;code&gt;StudlyCaps&lt;/code&gt;写法。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;PHP5.3&lt;/code&gt;之后的代码&lt;code&gt;必须&lt;/code&gt;使用正式的&lt;code&gt;命名空间(namespace)&lt;/code&gt;
例子：&lt;/p&gt;

&lt;p&gt;```php
&amp;lt;?php
// PHP 5.3 及之后:
namespace Vendor\Model;&lt;/p&gt;

&lt;p&gt;class Foo
{
}
```&lt;/p&gt;

&lt;p&gt;&lt;code&gt;PHP5.2.x&lt;/code&gt;之前的代码&lt;code&gt;建议&lt;/code&gt;用伪命名空间&lt;code&gt;Vendor_&lt;/code&gt;作为&lt;code&gt;类名(class name)&lt;/code&gt;的前缀&lt;/p&gt;

&lt;p&gt;&lt;code&gt;php
&amp;lt;?php
// PHP 5.2.x 及之前:
class Vendor_Model_Foo
{
}
&lt;/code&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;section-5&quot;&gt;类的常量、属性和方法&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;术语&lt;code&gt;类(class)&lt;/code&gt;指所有的&lt;code&gt;类(class)&lt;/code&gt;，&lt;code&gt;接口(interface)&lt;/code&gt;和&lt;code&gt;特性(trait)&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-6&quot;&gt;4.1. 常量&lt;/h3&gt;

&lt;p&gt;类常量&lt;code&gt;必须&lt;/code&gt;只由大写字母和&lt;code&gt;下划线(_)&lt;/code&gt;组成。
例子：&lt;/p&gt;

&lt;p&gt;```php
&amp;lt;?php
namespace Vendor\Model;&lt;/p&gt;

&lt;p&gt;class Foo
{
    const VERSION = ‘1.0’;
    const DATE_APPROVED = ‘2012-06-01’;
}
```&lt;/p&gt;

&lt;h3 id=&quot;section-7&quot;&gt;4.2. 属性&lt;/h3&gt;

&lt;p&gt;本指南中故意不对&lt;code&gt;$StulyCaps&lt;/code&gt;，&lt;code&gt;$camelCase&lt;/code&gt;或者&lt;code&gt;$unser_score&lt;/code&gt;中的某一种风格作特别推荐，完全由读者依据个人喜好决定属性名的命名风格。&lt;/p&gt;

&lt;p&gt;但是不管你如何定义属性名，&lt;code&gt;建议&lt;/code&gt;在一个合理的范围内保持一致。这个范围可能是&lt;code&gt;组织(vendor)&lt;/code&gt;级别的，&lt;code&gt;包(package)&lt;/code&gt;级别的，&lt;code&gt;类(class)&lt;/code&gt;级别的，或者&lt;code&gt;方法(method)&lt;/code&gt;级别的。&lt;/p&gt;

&lt;h3 id=&quot;section-8&quot;&gt;4.3. 方法&lt;/h3&gt;

&lt;p&gt;方法名则&lt;code&gt;必须&lt;/code&gt;使用&lt;code&gt;camelCase()&lt;/code&gt;风格来声明。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>PSR1代码规范0</title>
   <link href="https://zhuiyi1997.github.io//2016/10/16/psr0.html"/>
   <updated>2016-10-16T00:00:00+08:00</updated>
   <id>urn:uuid:b87da13a-a4dd-402f-b06a-cef7eeee2d80</id>
   <content type="html">&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;已弃用&lt;/strong&gt; - 截止到2014年10月21日，PSR-0已被弃用。 推荐替代使用&lt;a href=&quot;http://www.php-fig.org/psr/psr-4/&quot;&gt;PSR-4&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;下文描述了若要使用一个通用的&lt;code&gt;自动加载器(autoloader)&lt;/code&gt;，你所需要遵守的规范：&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;规范&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;一个完全标准的&lt;code&gt;命名空间(namespace)&lt;/code&gt;和&lt;code&gt;类(class)&lt;/code&gt;的结构是这样的：&lt;code&gt;\&amp;lt;Vendor Name&amp;gt;\(&amp;lt;Namespace&amp;gt;\)*&amp;lt;Class Name&amp;gt;&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;每个&lt;code&gt;命名空间(namespace)&lt;/code&gt;都必须有一个顶级的&lt;code&gt;空间名(namespace)&lt;/code&gt;(“&lt;code&gt;组织名(Vendor Name)&lt;/code&gt;”)。&lt;/li&gt;
  &lt;li&gt;每个&lt;code&gt;命名空间(namespace)&lt;/code&gt;中可以根据需要使用任意数量的&lt;code&gt;子命名空间(sub-namespace)&lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;从文件系统中加载源文件时，&lt;code&gt;空间名(namespace)&lt;/code&gt;中的分隔符将被转换为 &lt;code&gt;DIRECTORY_SEPARATOR&lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;类名(class name)&lt;/code&gt;中的每个下划线&lt;code&gt;_&lt;/code&gt;都将被转换为一个&lt;code&gt;DIRECTORY_SEPARATOR&lt;/code&gt;。下划线&lt;code&gt;_&lt;/code&gt;在&lt;code&gt;空间名(namespace)&lt;/code&gt;中没有什么特殊的意义。&lt;/li&gt;
  &lt;li&gt;完全标准的&lt;code&gt;命名空间(namespace)&lt;/code&gt;和&lt;code&gt;类(class)&lt;/code&gt;从文件系统加载源文件时将会加上&lt;code&gt;.php&lt;/code&gt;后缀。&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;组织名(vendor name)&lt;/code&gt;，&lt;code&gt;空间名(namespace)&lt;/code&gt;，&lt;code&gt;类名(class name)&lt;/code&gt;都由大小写字母组合而成。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-1&quot;&gt;示例&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;\Doctrine\Common\IsolatedClassLoader&lt;/code&gt; =&amp;gt; &lt;code&gt;/path/to/project/lib/vendor/Doctrine/Common/IsolatedClassLoader.php&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;\Symfony\Core\Request&lt;/code&gt; =&amp;gt; &lt;code&gt;/path/to/project/lib/vendor/Symfony/Core/Request.php&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;\Zend\Acl&lt;/code&gt; =&amp;gt; &lt;code&gt;/path/to/project/lib/vendor/Zend/Acl.php&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;\Zend\Mail\Message&lt;/code&gt; =&amp;gt; &lt;code&gt;/path/to/project/lib/vendor/Zend/Mail/Message.php&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;namespaceclass-name&quot;&gt;&lt;code&gt;空间名(namespace)&lt;/code&gt;和&lt;code&gt;类名(class name)&lt;/code&gt;中的下划线&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;\namespace\package\Class_Name&lt;/code&gt; =&amp;gt; &lt;code&gt;/path/to/project/lib/vendor/namespace/package/Class/Name.php&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;\namespace\package_name\Class_Name&lt;/code&gt; =&amp;gt; &lt;code&gt;/path/to/project/lib/vendor/namespace/package_name/Class/Name.php&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;以上是我们为实现通用的自动加载而制定的最低标准。你可以利用能够自动加载&lt;code&gt;PHP 5.3&lt;/code&gt;类的&lt;code&gt;SplClassLoader&lt;/code&gt;来测试你的代码是否符合这些标准。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;实例&lt;/h2&gt;

&lt;p&gt;下面是一个怎样利用上述标准来实现自动加载的示例函数。&lt;/p&gt;

&lt;p&gt;```php
&amp;lt;?php&lt;/p&gt;

&lt;p&gt;function autoload($className)
{
    $className = ltrim($className, ‘\’);
    $fileName  = ‘’;
    $namespace = ‘’;
    if ($lastNsPos = strrpos($className, ‘\’)) {
        $namespace = substr($className, 0, $lastNsPos);
        $className = substr($className, $lastNsPos + 1);
        $fileName  = str_replace(‘\’, DIRECTORY_SEPARATOR, $namespace) . DIRECTORY_SEPARATOR;
    }
    $fileName .= str_replace(‘_’, DIRECTORY_SEPARATOR, $className) . ‘.php’;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;require $fileName; } ```
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;splclassloader&quot;&gt;&lt;code&gt;SplClassLoader&lt;/code&gt;实现&lt;/h2&gt;

&lt;p&gt;下面的gist是一个按照上面建议的标准来自动加载类的&lt;code&gt;SplClassLoader&lt;/code&gt;实例。这是依据这些标准来加载&lt;code&gt;PHP 5.3&lt;/code&gt;类的推荐方案。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://gist.github.com/221634&quot;&gt;http://gist.github.com/221634&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</content>
 </entry>
 
 <entry>
   <title>浅谈MVC架构模式分析与设计</title>
   <link href="https://zhuiyi1997.github.io//2016/09/01/mvc-talk-lightly.html"/>
   <updated>2016-09-01T00:00:00+08:00</updated>
   <id>urn:uuid:b87da13a-a4dd-402f-b06a-cef7eeee2d80</id>
   <content type="html">&lt;hr /&gt;

&lt;!-- more --&gt;

&lt;p&gt;MVC全名是Model View Controller ,是模型-视图-控制器的缩写。&lt;/p&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;p&gt;视图：我们能能直观的看到的web界面。&lt;/p&gt;

&lt;p&gt;控制器：向系统发出指令的工具和帮手。&lt;/p&gt;

&lt;p&gt;模型：模型的工作是按要求从数据库取出数据。&lt;/p&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;p&gt;学习MVC的目的：&lt;/p&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;p&gt;1、快速上手各大主流PHP框架，列如YII框架、thinkphp、ci等&lt;/p&gt;

&lt;p&gt;2、快速适应多数公司的web开发需求&lt;/p&gt;

&lt;p&gt;3、逐步接触和了解web系统架构的知识、为日后成为系统架构的中坚力量做准备&lt;/p&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;p&gt;MVC解决的问题：&lt;/p&gt;

&lt;p&gt;```
在PHP还不支持面向对象之前，是过程化的方式来创建的，它们将 Model View Controller 三层的代码混在一起，十分混乱。&lt;/p&gt;

&lt;p&gt;它解决的问题有：维护难、开发速度慢、二次开发难度高，工作量大&lt;/p&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;p&gt;MVC的优势：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/res/img/blog/PHP学习/MVC_1.jpg&quot; alt=&quot;MVC_1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;MVC的工作流程初步认识：&lt;/p&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;p&gt;1、浏览者 -&amp;gt; 调用控制器，对它发出指令
2、控制器 -&amp;gt; 按指令选取一个合适的模型
3、模型 -&amp;gt; 安控制器指令去相应数据
4、控制器 -&amp;gt; 按指令选取相应视图
5、视图 -&amp;gt; 把第三步取到的数据按用户想要的样子显示出来&lt;/p&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;p&gt;NVC的目录结构：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/res/img/blog/PHP学习/MVC_2.jpg&quot; alt=&quot;MVC_2&quot; /&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>mysql事物处理</title>
   <link href="https://zhuiyi1997.github.io//2016/08/05/php-thing.html"/>
   <updated>2016-08-05T00:00:00+08:00</updated>
   <id>urn:uuid:b87da13a-a4dd-402f-b06a-cef7eeee2d80</id>
   <content type="html">&lt;hr /&gt;

&lt;!-- more --&gt;

&lt;p&gt;事务处理在各种管理系统中都有着广泛的应用。比如人员管理系统，很多同步数据库操作大都需要用到事务处理。&lt;/p&gt;

&lt;p&gt;比如说，在人员管理系统中，你删除一个人员，你即需要删除人员的基本资料，也要删除和该人员相关的信息，如信箱，文章等等，这样，这些数据库操作语句就构成一个事务！&lt;/p&gt;

&lt;p&gt;例子：删除的SQL语句&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;delete from userinfo where ~~~
delete from mail where ~~
delete from article where~~
~~
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果没有事务处理，在你删除的过程中，假设出错了，只执行了第一句，那么其后果是难以想象的！&lt;/p&gt;

&lt;p&gt;但用事务处理。如果删除出错，你只要rollback就可以取消删除操作（其实是只要你没有commit你就没有确实的执行该删除操作）&lt;/p&gt;

&lt;p&gt;一般来说，在商务级的应用中，都必须考虑事务处理的！&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;查看inodb信息&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  shell&amp;gt; /usr/local/mysql -u root -p

  mysql&amp;gt; show variables like &quot;have_%&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;系统会提示：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;p&gt;+——————+——-+
| Variable_name     | Value |
+——————+——-+
| have_bdb          | YES    |
| have_crypt        | YES    |
| have_innodb       | YES    |
| have_isam         | YES    |
| have_raid         | YES    |
| have_symlink      | YES    |
| have_openssl      | NO     |
| have_query_cache | YES    |
+——————+——-+
8 rows in set (0.05 sec)&lt;/p&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;如果是这样的，那么我们就可以创建一张支持事务处理的表来试试了。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;先简单介绍一下事务吧！事务是DBMS得执行单位。它由有限得数据库操作序列组成得。但不是任意得数据库操作序列都能成为事务。&lt;/p&gt;

&lt;p&gt;一般来说，事务是必须满足4个条件（ACID）:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;原子性（Autmic）：事务在执行性，要做到“要么不做，要么全做！”，就是说不允许事务部分得执行。

即使因为故障而使事务不能完成，在rollback时也要消除对数据库得影响！

一致性（Consistency）：事务得操作应该使数据库从一个一致状态转变倒另一个一致得状态！

就拿网上购物来说吧，你只有即让商品出库，又让商品进入顾客得购物篮才能构成事务！ 

隔离性（Isolation）：如果多个事务并发执行，应象各个事务独立执行一样！

持久性（Durability）：一个成功执行得事务对数据库得作用是持久得，即使数据库应故障出错，也应该能够恢复！
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;MYSQL的事务处理主要有两种方法。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1、用begin,rollback,commit来实现

	begin 开始一个事务

    rollback 事务回滚

    commit  事务确认

2、直接用set来改变mysql的自动提交模式

	MYSQL默认是自动提交的，也就是你提交一个QUERY，它就直接执行！我们可以通过

	set autocommit=0	禁止自动提交

	set autocommit=1 	开启自动提交来实现事务的处理。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但注意当你用 set autocommit=0 的时候，你以后所有的SQL都将做为事务处理，直到你用commit确认或rollback结束。&lt;/p&gt;

&lt;p&gt;注意当你结束这个事务的同时也开启了个新的事务！按第一种方法只将当前的作为一个事务！&lt;/p&gt;

&lt;p&gt;个人推荐使用第一种方法！&lt;/p&gt;

&lt;p&gt;注：MYSQL中只有INNODB和BDB类型的数据表才能支持事务处理！其他的类型是不支持的！（切记！）&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;MYSQL5.0 WINXP下测试通过～   ^_^&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;p&gt;mysql&amp;gt; use test;
Database changed
mysql&amp;gt; CREATE TABLE &lt;code&gt;dbtest&lt;/code&gt;(
     -&amp;gt; id int(4)
     -&amp;gt; ) TYPE=INNODB;
Query OK, 0 rows affected, 1 warning (0.05 sec)&lt;/p&gt;

&lt;p&gt;mysql&amp;gt; select * from dbtest
     -&amp;gt; ;
Empty set (0.01 sec)&lt;/p&gt;

&lt;p&gt;mysql&amp;gt; begin;
Query OK, 0 rows affected (0.00 sec)&lt;/p&gt;

&lt;p&gt;mysql&amp;gt; insert into dbtest value(5);
Query OK, 1 row affected (0.00 sec)&lt;/p&gt;

&lt;p&gt;mysql&amp;gt; insert into dbtest value(6);
Query OK, 1 row affected (0.00 sec)&lt;/p&gt;

&lt;p&gt;mysql&amp;gt; commit;
Query OK, 0 rows affected (0.00 sec)&lt;/p&gt;

&lt;p&gt;mysql&amp;gt; select * from dbtest;
+——+
| id    |
+——+
|     5 |
|     6 |
+——+
2 rows in set (0.00 sec)&lt;/p&gt;

&lt;p&gt;mysql&amp;gt; begin;
Query OK, 0 rows affected (0.00 sec)&lt;/p&gt;

&lt;p&gt;mysql&amp;gt; insert into dbtest values(7);
Query OK, 1 row affected (0.00 sec)&lt;/p&gt;

&lt;p&gt;mysql&amp;gt; rollback;
Query OK, 0 rows affected (0.00 sec)&lt;/p&gt;

&lt;p&gt;mysql&amp;gt; select * from dbtest;
+——+
| id    |
+——+
|     5 |
|     6 |
+——+
2 rows in set (0.00 sec)&lt;/p&gt;

&lt;p&gt;mysql&amp;gt;&lt;/p&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;p&gt;[PHP]
function Tran( $sql ) {
         $judge = 1;
         mysql_query(‘begin’);
         foreach ($sql as $v) {
                 if ( !mysql_query($v) ) {
                         $judge = 0;
                 }
         }
         if ($judge == 0) {
                 mysql_query(‘rollback’);
                 return false;
         }
         elseif ($judge == 1) {
                 mysql_query(‘commit’);
                 return true;
         }
}
[/PHP]&lt;/p&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;?php
$handler=mysql_connect(&quot;localhost&quot;,&quot;root&quot;,&quot;&quot;);
mysql_select_db(&quot;task&quot;);
mysql_query(&quot;SET AUTOCOMMIT=0&quot;);//设置为不自动提交，因为MYSQL默认立即执行
mysql_query(&quot;BEGIN&quot;);//开始事务定义
if(!mysql_query(&quot;insert into trans (id) values(&#39;2&#39;)&quot;))
{
mysql_query(&quot;ROOLBACK&quot;);//判断当执行失败时回滚
}
if(!mysql_query(&quot;insert into trans (id) values(&#39;4&#39;)&quot;))
{
mysql_query(&quot;ROOLBACK&quot;);//判断执行失败回滚
}
mysql_query(&quot;COMMIT&quot;);//执行事务
mysql_close($handler);

?&gt;

&lt;p&gt;```&lt;/p&gt;
</content>
 </entry>
 
 
</feed>
